/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSRender.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"

@class FSLayerContext;

NS_ASSUME_NONNULL_BEGIN

/**
 * @brief Enumeration for image type.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSInteger, FSImageType) {
    /** @brief Unknown image type. */
    e_imageTypeUnknown = -1,
    /**
     * @brief No image type.
     *
     * @note This is only for a newly constructed empty FSImage object.
     */
    e_imageTypeNone = 0,
    /** @brief Image type is BMP. */
    e_imageTypeBMP = 1,
    /** @brief Image type is JPG or JPeg. */
    e_imageTypeJPG = 2,
    /** @brief Image type is PNG. */
    e_imageTypePNG = 3,
    /** @brief Image type is GIF. */
    e_imageTypeGIF = 4,
    /** @brief Image type is TIF or TIFF. */
    e_imageTypeTIF = 5,
    /** @brief Image type is JPX or JPeg-2000. */
    e_imageTypeJPX = 6,
    /**
     * @brief Image type is JBIG2.
     * @note Currently, only few functions in class FSImage support this type.
     */
    e_imageTypeJBIG2 = 8
};

/************************************************************************************************
 *									Render   													*
 *************************************************************************************************/

/**
 * @brief	Class to access a bitmap.
 *
 * @details	Bitmap is one of most important data structures in Foxit PDF SDK.
 *			It is commonly used for rendering.
 */
@interface FSBitmap : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a bitmap.
 *
 * @details	If the parameter <i>buffer</i> is not <b>nil</b>, it should be initialized by application;
 *			otherwise, Foxit PDF SDK will allocate and initialize the pixels buffer internally. <br>
 *			Application is suggested to use the same colors to initialize bitmap' pixels buffer as Foxit PDF SDK uses internally:
 *			<ul>
 *			<li>For the bitmap without alpha channel, initialize the pixels buffer with 0xFFFFFFFF.</li>
 *			<li>For the bitmap with alpha channel, initialize the pixels buffer with 0x00000000.</li>
 *			</ul>
 *
 * @param[in]	width		Width of a bitmap, in pixels. This should be above 0.
 * @param[in]	height		Height of a bitmap, in pixels. This should be above 0.
 * @param[in]	format		Bitmap format type.
 *							Please refere to {@link FSDIBFormat::e_dibRgb FSDIBFormat::e_dibXXX} values and it should be one of these values,
 *							except {@link FSDIBFormat::e_dibInvalid}.
 * @param[in]	buffer		A buffer that specifies bitmap data.<br>
 *							If it is not <b>nil</b>, this function will use the parameter <i>buffer</i> to initialize a bitmap.
 *							Please keep the buffer valid during the life-cycle of the bitmap.<br>
 * 							If it is <b>nil</b>, a new bitmap buffer will be created internally.
 * @param[in]	pitch		The number of bytes for each scan line and only useful when parameter <i>buffer</i> is used.
 *							If 0, 4-byte alignment is assumed.
 *
 * @return	A new bitmap instance.
 */
-(id)initWithWidth: (int)width height: (int)height format: (FSDIBFormat)format buffer: (unsigned char * _Nullable)buffer pitch: (int)pitch;
/**
 * @brief	Create a bitmap.
 *
 * @param[in]	image		A UIImage object.
 *
 * @return	A new bitmap instance.
 */
-(FSBitmap*)initWithUIImage: (UIImage*)image;
/**
 * @brief	Clone current bitmap, with specified clip rectangle.
 *
 * @param[in]	clip	The clipping region in current bitmap, which is to be cloned. <br>
 *						<ul>
 *						<li> For rest format, this can be either <b>nil</b> or valid.  If this is <b>nil</b>, that means to clone the whole bitmap.
 *							 If this is not <b>nil</b>, it specifies a clipping region in bitmap to be cloned
 *							 and the cloned bitmap will have the same size as the clipping region.
 *						</li>
 *						</ul>
 *
 * @return	A new bitmap as clone result.
 */
-(FSBitmap*)clone: (FSRectI* _Nullable)clip;
/**
 * @brief	Get bitmap width.
 *
 * @return	Bitmap width.
 *			If any error occurs, -1 will be returned.
 */
-(int)getWidth;
/**
 * @brief	Get bitmap height.
 *
 * @return	Bitmap height.
 *			If any error occurs, -1 will be returned.
 */
-(int)getHeight;
/**
 * @brief	Get bitmap pitch.
 *
 * @return	Bitmap pitch.
 *			If any error occurs, -1 will be returned.
 */
-(int)getPitch;
/**
 * @brief	Get bitmap bits-per-pixel.
 *
 * @return	Bitmap bits-per-pixel value.
 *			If any error occurs, -1 will be returned.
 */
-(int)getBpp;
/**
 * @brief	Get bitmap buffer.
 *
 * @details	Bitmap data are organized in scan-lines, from top to down.
 *
 * @return	Bitmap buffer data.
 *			If any error occurs, <b>nil</b> will be returned.
 */
-(NSData *)getBuffer;
/**
 * @brief	Get bitmap format.
 *
 * @return	Format value.
 *			Please refer to {@link FSDIBFormat::e_dibInvalid FSDIBFormat::e_dibXXX} values and this would be one of these values.
 */
-(FSDIBFormat)getFormat;
/**
 * @brief	Fill current bitmap with a specified color.
 *
 * @param[in]	color		Color that used to fill bitmap. Format: 0xAARRGGBB
 * @param[in]	rect		Rectangle that specifies a region in bitmap, where the color will be filled.
 *							This can be <b>nil</b>, which means to fill the whole bitmap.
 */
-(void)fillRect: (unsigned int)color rect: (FSRectI* _Nullable)rect;

/** @brief Free the object. */
-(void)dealloc;

@end
/**
 * @brief	Enumeration for render color mode.
 *
 * @details	Values of this enumeration can be used alone.
 */
typedef NS_ENUM(NSUInteger, FSRenderColorMode) {
    /** @brief	Normal color mode. */
    e_colorModeNormal = 0,
    /** @brief	Map a color value to the color range defined by a background color and a foreground color. */
    e_colorModeMapping = 2
};

/**
 * @brief	Enumeration for render content flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSRenderContentFlag) {
    /** @brief	If set, page content will be rendered. */
    e_renderPage = 1 << 0,
    /** @brief	If set, annotations will be rendered. */
    e_renderAnnot = 1 << 1
};

/**
 * @brief	Enumeration for render device type.
 *
 * @details	Values of this enumeration can be used alone.
 */
typedef NS_ENUM(NSUInteger, FSDeviceType) {
    /** @brief	Device type: printer. */
    e_deviceTypePrinter = 0,
    /** @brief	Device type: display device. */
    e_deviceTypeDisplay = 1
};

/**
 * @brief	Class to access PDF render operation.
 *
 * @details	PDF renderer is a graphics engine and is used to render page to a bitmap or a device.
 *			This class offers functions to set rendering options, and render page and annotations. <br>
 *			A ::FSRenderer object is created by function {@link FSRenderer::create:rgbOrder:} or {@link FSRenderer::createFromContext:deviceType:}.
 *			There are two ways to do rendering:
 *			<ul>
 *			<li>To render page and annotations, use functions {@link FSRenderer::startRender:matrix:pause:} and {@link FSRenderer::continueRender}.
 *				Function {@link FSRenderer::setRenderContent:} can be used to decide whether to render page and annotation both or not.</li>
 *			<li>To render a single annotation, use function {@link FSRenderer::renderAnnot:matrix:}.</li>
 *			</li>
 *			<li>To render a bitmap, use function {@link FSRenderer::startRenderBitmap:matrix:clipRect:interpolation:pause:} and {@link FSRenderer::continueRender}.</li>
 *			<li>To render a reflow page, use function {@link FSRenderer::startRenderReflowPage:matrix:pause:} and {@link FSRenderer::continueRender}.</li>
 *			</ul>
 */
@interface FSRenderer : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a renderer object from bitmap.
 *
 * @param[in]	bitmap		A bitmap used for rendering.
 * @param[in]	rgbOrder	<b>YES</b> means Foxit PDF SDK needs to use RGB byte-order
 *							(Red is in the lowest order) when rendering.<br>
 *							<b>NO</b> means Foxit PDF SDK needs to use BGR byte-order
 *							(Blue is in the lowest order) when rendering.
 *
 * @return	A new renderer object.
 */
-(id _Nullable)initWithBitmap: (FSBitmap*)bitmap rgbOrder: (BOOL)rgbOrder;
/**
 * @brief	Create a renderer object from device context.
 *
 * @param[in]	context		A CGContextRef object.
 * @param[in]	deviceType	The device type of parameter <i>context</i>.
 *
 * @return	A new renderer object.
 */
+(FSRenderer* _Nullable)createFromContext: (CGContextRef)context deviceType: (FSDeviceType)deviceType;

/**
 * @brief Start to quickly render a PDF page, mainly for thumbnail purpose.This is progressive, which means that the job may not finished when it return.
 *
 * @details This function is mainly used for render a page for thumbnail purpose.
 *          The rendered content will not be completed: all the annotations will be ignored, event if
 *          flag {@link foxit::e_renderAnnot FSRenderContentFlag::e_renderAnnot} is set by function
 *          {@link FSRenderer::SetRenderContentFlags}; text content will become blurred and
 *          will be replace by pixel point.<br>
 *          It may still take a long time to do this quick rendering when page has complex or large contents,
 *          so Foxit PDF SDK uses a progressive process to do this.
 *
 * @param[in] page    A PDF page. It should not be <b>NULL</b> and should have been parsed.
 * @param[in] matrix  The transformation matrix used for rendering, which is usually returned by function
 *                    {@link FSPDFPage::GetDisplayMatrix}.
 * @param[in] pause   Pause callback object which decides if the rendering process needs to be paused.
 *                    This can be <b>NULL</b> which means not to pause during the rendering process.
 *                    If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive * _Nullable)startQuickRender: (FSPDFPage *)page matrix: (FSMatrix *)matrix pause: (FSPauseCallback* _Nullable)pause;

/**
 * @brief Start to render a PDF page.This is progressive, which means that the job may not finished when it return.
 *
 * @details It may take a long time to render a page with complex or large contents, so Foxit PDF SDK uses
 *          a progressive process to do this.
 *
 * @param[in] page    A PDF page. It should not be <b>NULL</b>.
 *                    If only to render annotations (that means only
 *                    {@link foxit::e_renderAnnot FSRenderContentFlag::e_renderAnnot} is set by function
 *                    {@link FSRenderer::SetRenderContentFlags}), there is no need to parse the input page;
 *                    otherwise the input page should have been parsed.
 * @param[in] matrix  The transformation matrix used for rendering, which is usually returned by function
 *                    {@link FSPDFPage::GetDisplayMatrix}.
 * @param[in] pause   Pause callback object which decides if the rendering process needs to be paused.
 *                    This can be <b>NULL</b> which means not to pause during the rendering process.
 *                    If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(FSProgressive * _Nullable)startRender: (FSPDFPage*)page matrix: (FSMatrix*)matrix pause: (FSPauseCallback* _Nullable)pause;

/**
 * @brief Start to render a reflow page to current renderer's related device object.This is progressive, which means that the job may not finished when it return.
 *
 * @details It will take a long time to render a reflow page with complex or large contents, so Foxit PDF SDK uses
 *          a progressive process to do this.<br>
 *          If the rendering is not finished, please call function {@link FSRenderer::ContinueRender} to
 *          continue the rendering until it is finished.
 *
 * @param[in] reflow_page  A reflow page. It should be parsed.
 * @param[in] matrix       The transformation matrix used for rendering, which is usually returned by function
 *                         {@link FSReflowPage::GetDisplayMatrix}.
 * @param[in] pause        Pause callbackobject which decides if the rendering process needs to be paused.
 *                         This can be <b>NULL</b> which means not to pause during the rendering process.
 *                         If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive * _Nullable)startRenderReflowPage: (FSReflowPage*)reflowPage matrix: (FSMatrix*) matrix pause: (FSPauseCallback* _Nullable)pause;
/**
 * @brief Start to render a bitmap to current renderer's related device object.This is progressive, which means that the job may not finished when it return.
 *
 * @details It will take a long time to render a bitmap with complex or large contents, so Foxit PDF SDK uses
 *          a progressive process to do this.<br>
 *          If the rendering is not finished, please call function {@link FSRenderer::ContinueRender} to
 *          continue the rendering until it is finished.
 *
 * @param[in] bitmap         A bitmap. It should be valid.
 *                           User should ensure the bitmap to keep valid until current rendering process is finished.
 * @param[in] matrix         The transformation matrix used for rendering. This matrix is used as image matrix: <br>
 *                           assume that <i>h</i> is image height, <i>w</i> is image width, and then matrix
 *                           [w 0 0 h 0 0] will produce an identical image.
 * @param[in] clip_rect      Clip rectangle of the render device. This can be <b>NULL</b>.
 * @param[in] interpolation  Bitmap interpolation flags. Please refer to
 *                           {@link FSBitmapInterpolationFlag::e_interpolationDownsample FSBitmapInterpolationFlag::e_interpolationXXX}
 *                           values and this can be one or a combination of these values. This can be 0.
 * @param[in] pause          Pause callback object which decides if the rendering process needs to be paused.
 *                           This can be <b>NULL</b> which means not to pause during the rendering process.
 *                           If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive * _Nullable)startRenderBitmap: (FSBitmap*)bitmap matrix: (FSMatrix*)matrix clipRect: (FSRectI*)clipRect interpolation: (FSBitmapInterpolationFlag)interpolation pause: (FSPauseCallback* _Nullable)pause;

/**
 * @brief	Render a specified annotation.
 *
 * @details	When this function is called, render flag (set by function {@link FSRenderer::setRenderContent:} or by default) will be ignored.
 *
 * @param[in]	annot		An annotation object to be rendered.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix*)matrix;
/**
 * @brief	Set render flag to decide what content will be rendered.
 *
 * @details	If this function is not called, default value ({@link FSRenderContentFlag::e_renderPage} | {@link FSRenderContentFlag::e_renderAnnot}) will be used.
 *
 * @param[in]	renderContentFlag		Render content flags.
 *										Please refere to {@link FSRenderContentFlag::e_renderPage FSRenderContentFlag::e_renderXXX} values
 *										and this should be one or a combination of these values.
 */
-(void)setRenderContent: (FSRenderContentFlag)renderContentFlag;
/**
 * @brief	Decide whether to transform annotation icon or not when display.
 *
 * @details	The flag set by this function is only useful for note and file attachment annotations.
 *			If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	transformAnnotIcon			<b>YES</b> means to transform annotation icon when display.
 *											<b>NO</b> means not to transform annotation icon when display.
 */
-(void)setTransformAnnotIcon: (BOOL)transformAnnotIcon;

/**
 * @brief	Set layer context to render context handle.
 *
 * @param[in]	layerContext		Handle to a <b>FSLayerContext</b> object which is a PDF layer context object.
 *
 * @note	In order to render one layer when to render PDF contents on a rendering context,
 *			user should call this function to set the layer context to render context.
 */
-(void)setLayerContext: (FSLayerContext*)layerContext;

/**
 * @brief	Set color mode.
 *
 * @details	If this function is not called, default value {@link FSRenderColorMode::e_colorModeNormal} will be used.
 *
 * @param[in]	colorMode	Color mode value. It should be one of following values:
 *							<ul>
 *							<li>{@link FSRenderColorMode::e_colorModeNormal} means normal color mode.</li>
 *							<li>{@link FSRenderColorMode::e_colorModeMapping} means map a color value to the color range defined by a background color and a foreground color.
 *								If this mode is used, please call function {@link FSRenderer::setMappingModeColors:foreColor:} to set "background color" and "foreground color".</li>
 *							</ul>
 */
-(void)setColorMode: (FSRenderColorMode)colorMode;
/**
 * @brief	Set background color and foreground color when color mode is set {@link FSRenderColorMode::e_colorModeMapping}.
 *
 * @param[in]	backColor		The background color.
 * @param[in]	foreColor		The foreground color.
 */
-(void)setMappingModeColors: (unsigned int)backColor foreColor: (unsigned int)foreColor;
/**
 * @brief	Decide whether to use halftone for image stretching.
 *
 * @details	If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	isForceHalftone	<b>YES</b> means to use halftone for image stretching.
 *								<b>NO</b> means not to use halftone for image stretching.
 */
-(void)setForceHalftone: (BOOL)isForceHalftone;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief Class to access an image.
 *
 * @details Foxit PDF SDK offers following image types:<br>
 *          <ul>
 *          <li>BMP: bitmap image format. It only support single frame.
 *              Foxit PDF SDK supports to load image from a BMP image file,
 *              get some basic information, access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>JPG: joint photographic experts group image format. It only support single frame.
 *              Foxit PDF SDK supports to load image from a JPG image file,
 *              get some basic information, access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>PNG: portable network graphics image format. It only support single frame.
 *              Foxit PDF SDK supports to load image from a PNG image file,
 *              get some basic information, access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>GIF: graphics interchange format. It supports multiple frames.
 *              Foxit PDF SDK supports to load image from a GIF image file, get its size,
 *              access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>TIF: tagged image file format. It supports multiple frames.
 *              Foxit PDF SDK supports to load image from a TIF image file, get some basic information,
 *              access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>JPX: JPEG-2000 image format. It only support single frame.
 *              Foxit PDF SDK supports to load image from a JPX image file, get its size,
 *              access to its bitmap, change its bitmap and save it as an image file.
 *          </li>
 *          <li>JBIG2: JBIG2 image format. It only support single frame.
 *              Foxit PDF SDK supports to load image from a JBIG2 image file,
 *              get its size, and save it as an image file.
 *              Foxit PDF SDK does not support to access to its frame bitmap yet.
 *          </li>
 *          </ul>
 */
@interface FSImage : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief Construct an empty image.
 *
 * @return A new FSImage object.
 */
-(FSImage *)init;

/**
 * @brief Construct image from an existing image file path.
 *
 * @param[in] path  A full path of an existing image file path, including file name and extension.
 *                  It should be in UTF-8 encoding and should not be <b>NULL</b> or "empty".
 *
 * @return A new FSImage object.
 */
-(FSImage *)initWithFilePath: (NSString *)path;

/**
 * @brief Construct image with a memory buffer.
 *
 * @param[in] buffer  A memory buffer. The image file data should be fully loaded in this memory buffer.
 *                    It should not be <b>NULL</b>.
 *
 * @return A new FSImage object.
 */
-(FSImage *)initWithBuffer: (NSData *)buffer;

/**
 * @brief Construct image with a file read handler.
 *
 * @param[in] file_read  Pointer to a FSFileReadCallback object which is implied by user to load image.
 *
 * @return A new FSImage object.
 */
-(FSImage *)initWithFileRead: (id<FSFileReadCallback>)fileRead;

/**
 * @brief Get image type.
 *
 * @details If current image is created by function {@link FSImage::Create},
 *          its type would be {@link FSImageType::e_imageTypeNone FSImageType::e_imageTypeNone}.
 *
 * @return Image type.
 *         Please refer to {@link FSImageType::e_imageTypeUnknown FSImageType::e_imageTypeXXX}
 *         values and it would be one of these values.
 */
-(FSImageType)getType;

/**
 * @brief Get image width.
 *
 * @details If the image has multiple frames,
 *          usually the first frame's size will be treated as the image size.
 *
 * @return Image width.
 */
-(int)getWidth;

/**
 * @brief Get image height.
 *
 * @details If the image has multiple frames,
 *          usually the first frame's size will be treated as the image size.
 *
 * @return Image height.
 */
-(int)getHeight;

/**
 * @brief Get image frame count.
 *
 * @return The frame count.
 */
-(int)getFrameCount;

/**
 * @brief Get a frame bitmap, specified by index.
 *
 * @details This function can only support to get frame bitmap in following formats:<br>
 *          {@link FSDIBFormat::e_dib8bppMask FSDIBFormat::e_dib8bppMask},
 *          {@link FSDIBFormat::e_dib8bppMask FSDIBFormat::e_dib8bpp},
 *          {@link FSDIBFormat::e_dibRgb FSDIBFormat::e_dibRgb},
 *          {@link FSDIBFormat::e_dibRgb32 FSDIBFormat::e_dibRgb32},
 *          {@link FSDIBFormat::e_dibArgb FSDIBFormat::e_dibArgb}.<br>
 *          For other unsupported DIB format, this function will return <b>NULL</b>.
 *
 * @param[in] index  Index of the frame. Valid range: from 0 to (<i>count</i>-1).
 *                   <i>count</i> is returned by function {@link FSImage::GetFrameCount}.
 *
 * @return The frame bitmap.
 *      If there is any error, this function will return <b>NULL</b>.
 *      User should not release this bitmap.
 */
-(FSBitmap*)getFrameBitmap: (int)index;

/**
 * @brief Get DPI for X-axis.(Default:96)
 *
 * @details Currently, this method does not support
 *          {@link FSImageType::e_imageTypeJPX FSImageType::e_imageTypeJPX},
 *          {@link FSImageType::e_imageTypeGIF FSImageType::e_imageTypeGIF}
 *
 * @return DPI value for X-axis.
 */
-(int)getXDPI;

/**
 * @brief Get DPI for Y-axis.(Default:96)
 *
 * @details Currently, this method does not support
 *          {@link FSImageType::e_imageTypeJPX FSImageType::e_imageTypeJPX},
 *          {@link FSImageType::e_imageTypeGIF FSImageType::e_imageTypeGIF}
 *
 * @return DPI value for Y-axis.
 */
-(int)getYDPI;

/**
 * @brief Add a bitmap as a frame.
 *
 * @details For supporting image types:
 *          <ul>
 *          <li>If current image's type is {@link FSImageType::e_imageTypeTIF FSImageType::e_imageTypeTIF},
 *              {@link FSImageType::e_imageTypeGIF FSImageType::e_imageTypeGIF} or
 *              {@link FSImageType::e_imageTypeNone FSImageType::e_imageTypeNone},
 *              this function will add the new bitmap to be the new last frame.
 *          </li>
 *          <li>If current image's type is one of other types, which only contains single frame,
 *              this function will use the new bitmap to replace the first frame.</li>
 *          </ul>
 *
 * @param[in] bitmap  A bitmap as a frame to be added or set.
 *
 * @return <b>TRUE</b> means success, while <b>FALSE</b> means failure.
 */
-(BOOL)addFrame: (FSBitmap*)bitmap;

/**
 * @brief Set DPI for X-axis and Y-axis.
 *
 * @details Currently, this method does not support
 *         {@link FSImageType::e_imageTypeJPX FSImageType::e_imageTypeJPX},
 *         {@link FSImageType::e_imageTypeGIF FSImageType::e_imageTypeGIF}.
 *
 * @param[in] x_dpi  DPI for X-axis. It should be above 0.
 * @param[in] y_dpi  DPI for Y-axis. It should be above 0.
 *
 * @return None.
 */
-(void)setDPIs: (int)x_dpi y_dpi: (int)y_dpi;

/**
 * @brief Save current image as an image file.
 *
 * @details If the type of current image is
 *          {@link FSImageType::e_imageTypeTIF FSImageType::e_imageTypeTIF},
 *          {@link FSImageType::e_imageTypeGIF FSImageType::e_imageTypeGIF} or
 *          {@link FSImageType::e_imageTypeNone FSImageType::e_imageTypeNone},
 *          and the saved image file type does not support multiply frames,
 *          only the first frame of current image will be saved to the image file.<br>
 *          For a newly created image, by function {@link FSImage::Create},
 *          please ensure to add at least valid frame bitmap to it before using this function;
 *          otherwise this function will fail.
 *
 * @param[in] file_path  A full path of the saved image file, including file name and extension.
 *                            It should be in UTF-8 encoding and should not be <b>NULL</b> or empty.<br>
 *                            Currently, this function supports following extension names:<br>:
 *                            .bmp, .jpg, .jpeg, .png, .tif, .tiff, .jpx, .jp2.
 *
 * @return <b>TRUE</b> means success, while <b>FALSE</b> means failure.
 */
-(BOOL)saveAs: (NSString *)file_path;

-(void)dealloc;

@end

NS_ASSUME_NONNULL_END

