/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFLayer.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"

@class FSLayerPrintData;

NS_ASSUME_NONNULL_BEGIN
/**
 * @brief	Enumeration for PDF layer usage type.
 */
typedef NS_ENUM(NSUInteger, FSLayerUsageType) {
    /** @brief	Use for a viewer. */
    e_layerUsageTypeView = 0,
    /** @brief	Use for represent a document designer's structural organization of artwork. */
    e_layerUsageTypeDesign,
    /** @brief	Use for printing. */
    e_layerUsageTypePrint,
    /** @brief	Use for exporting. */
    e_layerUsageTypeExport,
    /** @brief	Use for zooming. */
    e_layerUsageTypeZoom
};

/**
 * @brief	Enumeration for PDF layer base state.
 */
typedef NS_ENUM(NSUInteger, FSLayerUsageState) {
    /** @brief	The state is ON. */
    e_layerStateON = 0,
    /** @brief	The state is OFF. */
    e_layerStateOFF,
    /** @brief	The state is unchanged. */
    e_layerStateUnchanged,
    /** @brief	The state is undefined. */
    e_layerStateUndefined
};

/**
 * @brief	Class to represent data for PDF layer zoom usage.
 *
 */
@interface FSLayerZoomData : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**@brief  Default Constructor. */
-(id)init;
/**
 * @brief	Constructor with parameters.
 *
 * @param[in]	minFactor		The minimum recommended magnification factor, in float.
 * @param[in]	maxFactor		The maximum recommended magnification factor, in float.
 *
 * @return  None.
 */
-(id)initWithMinFactor: (float)minFactor MaxFactor:(float)maxFactor;
/**@brief	Constructor with other data. */
-(id)initWithData: (FSLayerZoomData*)data;
/** @brief	Set the minimum and maxium magnification factor at which the group should be ON. A negative number means not to set the zoom floor.*/
-(void)set: (float)minFactor maxFactor: (float)maxFactor;
/** @brief	Set the minimum recommended magnification factor at which the group should be ON. A negative number means not to set the zoom floor.*/
-(void)setMinFactor: (float)value;
/** @brief	Get the minimum recommended magnification factor at which the group should be ON. A negative number means not to set the zoom floor.*/
-(float)getMinFactor;
/** @brief	Set the magnification factor below which the group should be ON. A negative number means not to set the zoom upper.*/
-(void)setMaxFactor: (float)value;
/** @brief	Get the magnification factor below which the group should be ON. A negative number means not to set the zoom upper.*/
-(float)getMaxFactor;
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief Class to access to a PDF layer.
 *
 * @details A PDF layer (known as "Optional content group" in <PDF reference 1.7>) is a collection of
 *          graphics (known as FSPDFGraphicsObject in Foxit PDF SDK) that can be made visible or invisible.
 *          These graphics belonging to the same layer can reside anywhere in the document:
 *          they need not be consecutive in drawing order, nor even belong to the same content stream.<br>
 *          If user wants to access a layer node, user must create a FSPDFLayerTree object first and then
 *          call function {@link FSLayerTree::getRootNode} to get the root of the whole layer tree.
 *          Here, "root layer node" is an abstract object. "root layer node" can only have some child layer nodes
 *          but no parent, or any data (such as name, intent and so on). And "root layer node" cannot be
 *          shown on the application UI since it has no data. So, for a root layer node, only functions
 *          {@link FSLayerNode::getChildrenCount} and {@link FSLayerNode::getChild:} can are useful.<br>
 *          This class offers methods to access to layer data and the graphics belonging to it. For example:
 *          <ul>
 *          <li>To access layer data, following functions can be used:
 *              {@link FSLayerNode::getName}, {@link FSLayerNode::getViewUsage}, {@link FSLayerNode::getExportUsage},
 *              {@link FSLayerNode::getPrintUsage}, {@link FSLayerNode::getZoomUsage} and setting methods for
 *              these data.</li>
 *          <li>To access the graphics belonging to it, use function {@link FSLayerNode::getGraphicsObjects:};
 *              function {@link FSLayerNode::addGraphicsObject:graphicsObject:} and {@link FSLayerNode::removeGraphicsObject:} can
 *              be used to add or remove a specified graphics object to the layer.</li>
 *          </ul>
 *
 * @see FSLayerTree
 */
@interface FSLayerNode : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the count of children nodes.
 *
 * @return	The count of children nodes.
 */
-(int)getChildrenCount;
/**
 * @brief	Get a child node.
 *
 * @param[in]	index	Index of the child to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSLayerNode::getChildrenCount}.
 *
 * @return	The count of children nodes.
 */
-(FSLayerNode*)getChild: (int)index;
/**
 * @brief	Get the name of current layer node.
 *
 * @return	Layer node name, in UTF-8 encoding.
 */
-(NSString*)getName;
/**
 * @brief	Check if current layer node is associated with a layer.
 *
 * @return	<b>YES</b> means current layer node is associated with a layer, while <b>NO</b> means current layer node is not associated with a layer.
 */
-(BOOL)hasLayer;
/**
 * @brief	Check if current layer node has a specified intent.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.<br>
 *          Specially, when fucntion {@link FSLayerNode::hasIntent:} returns <b>NO</b>, that means the layer related to
 *          current layer node will always be visible, and will not be affected by the changing in visiblity.
 *
 * @param[in]	intent	Intent name to be checked, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *						Pre-defined intent names are "View" and "Design".
 *
 * @return	<b>YES</b> means current layer node has the specified intent, while <b>NO</b> means current layer node does not the specified intent.
 */
-(BOOL)hasIntent: (NSString *)intent;
/**
 * @brief	Check if current layer node is in a specified PDF page.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.
 *
 * @param[in]	page	A PDF page.
 *
 * @return	<b>YES</b> means current layer node is in the specified PDF page,
 *			while <b>NO</b> means current layer node is not in the specified PDF page.
 */
-(BOOL)isInPage: (FSPDFPage*)page;
/**
 * @brief	Get the layer usage state for viewing.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.
 *
 * @return	Layer usage state.
 *			Please refer to {@link FSLayerUsageState::e_layerStateON FSLayerUsageState::e_layerStateXXX} values and it would be one of these values
 *			except {@link FSLayerUsageState::e_layerStateUnchanged}.
 */
-(FSLayerUsageState)getViewUsage;
/**
 * @brief	Get the layer usage state for exporting.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.
 *
 * @return	Layer usage state.
 *			Please refer to {@link FSLayerUsageState::e_layerStateON FSLayerUsageState::e_layerStateXXX} values and it would be one of these values
 *			except {@link FSLayerUsageState::e_layerStateUnchanged}.
 */
-(FSLayerUsageState)getExportUsage;
/**
 * @brief	Get the layer usage data for printing.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.
 *
 * @return	Layer print data.
 */
-(FSLayerPrintData*)getPrintUsage;
/**
 * @brief	Get the layer usage data for zooming.
 *
 * @details	This function is only useful when function {@link FSLayerNode::hasLayer} returns <b>YES</b>.
 *
 * @return	Layer zoom data.
 */
-(FSLayerZoomData*)getZoomUsage;
/**
 * @brief	Set the name of current layer node.
 *
 * @details The layer node should have a layer, or there will be an exception thrown.
 *
 * @param[in]	name	New layer node name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setName: (NSString *)name;
/**
 * @brief	Set default visibility.
 *
 * @details For special case when fucntion {@link FSLayerNode::hasIntent:} returns <b>NO</b>, that means the layer related to
 *          current layer node will always be visible, and will not be affected by the changing in visiblity.
 *
 * @param[in]	visible		<b>YES</b> means visible, and <b>NO</b> means invisible.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setDefaultVisible: (BOOL)visible;
/**
 * @brief	Set layer usage state for viewing.
 *
 * @details If user wants the new state to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	state		Layer usage state. It should be one of following values:
 *							<ul>
 *							<li>{@link FSLayerUsageState::e_layerStateON}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateOFF}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateUndefined} means to remove this property from current layer node</li>
 *							</ul>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setViewUsage: (FSLayerUsageState)state;
/**
 * @brief	Set layer usage state for exporting.
 *
 * @details If user wants the new state to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	state		Layer usage state. It should be one of following values:
 *							<ul>
 *							<li>{@link FSLayerUsageState::e_layerStateON}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateOFF}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateUndefined} means to remove this property from current layer node</li>
 *							</ul>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setExportUsage: (FSLayerUsageState)state;
/**
 * @brief	Set layer usage data for printing.
 *
 * @details If user wants the new layer print data to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	data		Layer print data. The value of {@link FSLayerPrintData::getPrintState} should be one of following values:
 *							<ul>
 *							<li>{@link FSLayerUsageState::e_layerStateON}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateOFF}</li>
 *							<li>{@link FSLayerUsageState::e_layerStateUndefined} means to remove this property from current layer node</li>
 *							</ul>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPrintUsage: (FSLayerPrintData*)data;
/**
 * @brief	Set layer usage data for zooming.
 *
 * @details If user wants the new layer zoom data to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	data		Layer zoom data.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setZoomUsage: (FSLayerZoomData*)data;
/**
 * @brief	Enumerate page objects and retrieve a page object which is related with a specific layer.
 *
 * @details	The type of page object(which is to be got) is specified by parameter <i>typeFilter</i>.
 *
 * @param[in]	page			A PDF page, to which the input graphics object belongs. It should be valid.
 *
 * @return	      The position of next page object. If there is no more page objects to be enumerated, a <b>FS_POSITION</b> object with value NULL will be returned.
 */
-(NSArray<FSPDFGraphicsObject*>*)getGraphicsObjects:(FSPDFPage*)page;
/**
 * @brief	Add a specified graphics object to current layer node.
 *
 * @details  Caller should re-generate the page content by invoke FSPDFGraphicsObject::generateContent when finish adding or removal.
 *
 * @param[in]	page			A PDF page, to which the input graphics object belongs. It should be valid.
 * @param[in]	graphicsObject	A graphics object to be added to current layer node.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)addGraphicsObject: (FSPDFPage*)page graphicsObject: (FSPDFGraphicsObject*)graphicsObject;
/**
 * @brief	Remove a specified graphics object from current layer node.
 *
 * @details	If the input graphics object does not belong to current layer node, this function will return <b>FALSE</b>.
 *          Caller should re-generate the page content by invoke FSPDFGraphicsObject::generateContent when finish adding or removal.
 *
 * @param[in]	graphicsObject	A graphics object to be removed.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeGraphicsObject: (FSPDFGraphicsObject*)graphicsObject;
/**
 * @brief	Remove a kind of usage property.
 *
 * @details	If current layer node does not have the specified usage or does not have any usage, this function will return <b>YES</b>.
 *
 * @param[in]	usageType	Layer usage type to be removed.
 *							Please refer to {@link FSLayerUsageType::e_layerUsageTypeView FSLayerUsageType::e_layerUsageTypeXXX} values and it should be one of these values.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeUsage: (FSLayerUsageType)usageType;
/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Set the base state for all layers in the default configuration.
 *
 * @details If user wants the new base state to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	state		Layer usage state.
 *							Please refer to {@link FSLayerUsageState::e_layerStateON FSLayerUsageState::e_layerStateXXX} values and it should be one of these values
 *							except {@link FSLayerUsageState::e_layerStateUndefined}.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 */
@interface FSLayerTree : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a layer tree object from a PDF document.
 *
 * @param[in]	doc		A PDF document object. It should be valid.
 *
 * @return	A new FSLayerTree object. If there is no layer in PDF document, this function will return <b>NULL</b>.
 */
- (FSLayerTree *)initWithPDFDoc:(FSPDFDoc *)doc;
/**
 * @brief	Set the base state for all layers in the default configuration.
 *
 * @details If user wants the new base state to have effect on rendering result, please create a new FSLayerContext object after this function succeeds,
 *          and then use the new FSLayerContext to FSRenderer to do rendering.
 *
 * @param[in]	state		Layer usage state.
 *							Please refer to {@link FSLayerUsageState::e_layerStateON FSLayerUsageState::e_layerStateXXX} values and it should be one of these values
 *							except {@link FSLayerUsageState::e_layerStateUndefined}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setBaseState: (FSLayerUsageState)state;
/**
 * @brief	Get the root layer node.
 *
 * @return	Root layer node.
 */
-(FSLayerNode*)getRootNode;
/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief Class to represent layer context.
 *
 * @details Layer context is used to decide graphics in which kind of layer's usage can be rendered when
 *          rendering pages.<br>
 *          To make layer's usage to affect the rendering result, user should first create a layer context by
 *          function {@link FSLayerContext::create:usageType:} with specified usage type and set this layer context to
 *          FSRenderer object by function {@link FSRenderer::setLayerContext:}, and then use this FSRenderer object
 *          to render page.<br>
 *          Class FSLayerContext also offer methods to:
 *          <ul>
 *          <li>copy or merge from another layer context object.</li>
 *          <li>check or set the visibility of a specified layer node.</li>
 *          </ul>
 *
 * @see FSRenderer
 */
@interface FSLayerContext : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a layer context object from a PDF document, based on a specified usage type.
 *
 * @param[in]	doc			A PDF document object. It should be valid.
 * @param[in]	usageType	Layer usage type.
 *							Please refer to {@link FSLayerUsageType::e_layerUsageTypeView FSLayerUsageType::e_layerUsageTypeXXX} values and it should be one of these values
 *							except value {@link FSLayerUsageType::e_layerUsageTypeZoom}.
 *
 * @return	A new FSLayerContext object.
 */
- (FSLayerContext *)initWithPDFDoc:(FSPDFDoc *)doc usageType:(FSLayerUsageType)usageType;
/**
 * @brief	Get the related PDF document.
 *
 * @return	The related PDF document object.
 */
-(FSPDFDoc*)getDocument;
/**
 * @brief	Get the layer usage type.
 *
 * @return	Layer usage type.
 *			Please refer to {@link FSLayerUsageType::e_layerUsageTypeView FSLayerUsageType::e_layerUsageTypeXXX} values and it would be one of these values
 *			except value {@link FSLayerUsageType::e_layerUsageTypeZoom}.
 */
-(FSLayerUsageType)getUsageType;
/**
 * @brief	Reset current layer context, back to the initialized state just after being created.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)reset;
/**
 * @brief	Copy states from another layer context.
 *
 * @param[in]	srcContext		The source layer context, whose state will be copied to current layer context.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)copyStates: (FSLayerContext*)srcContext;
/**
 * @brief	Merge states from another layer context.
 *
 * @param[in]	srcContext		The source layer context, whose state will be merged to current layer context.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)mergeStates: (FSLayerContext*)srcContext;
/**
 * @brief	Check if a specified layer node is visible in current layer context.
 *
 * @param[in]	layer		A layer node. It should belong to the same PDF document which is related to current layer context.
 *
 * @return	<b>YES</b> means the layer node is visible, while <b>NO</b> means the layer node is invisible.
 */
-(BOOL)isVisible: (FSLayerNode*)layer;
/**
 * @brief	Set the visibility of a specified layer node in current layer context.
 *
 * @details For special case when function {@link FSLayerNode::hasIntent:} returns <b>NO</b>, that means the layer related to
 *          the layer node will always be visible, and will not be affected by the changing in visiblity.
 *
 * @param[in]	layer		  A layer node. It should belong to the same PDF document which is related to current layer context.
 *                      This layer node should have a layer, otherwise an exception will be thrown.
 * @param[in]	visible		<b>YES</b> means visible, and <b>NO</b> means invisible.
 *
 * @return	<b>YES</b> means the layer node is visible, while <b>NO</b> means the layer node is invisible.
 */
-(BOOL)setVisible: (FSLayerNode*)layer visible: (BOOL)visible;
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent data for PDF layer print usage.
 *
 */
@interface FSLayerPrintData : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**@brief  Default constructor. */
-(id)init;
/**
 * @brief	Constructor with parameters.
 *
 * @param[in]	subType		specifying the kind of content controlled, In UTF-8 encoding.
 * @param[in]	state		Layer usage state, indicating that the group should be set to which state when the document is printed from a viewer application.
 *
 * @return	None.
 */
-(id)initWithSubType: (NSString*)subType PrintState:(FSLayerUsageState)state;
/**@brief	Constructor with the other data object. */
-(id)initWithData: (FSLayerPrintData*)data;
/**
 * @brief	Set value for current layer print usage.
 *
 * @param[in]	subtype			specifying the kind of content controlled, In UTF-8 encoding.
 * @param[in]	printState		Layer usage state, indicating that the group should be set to which state when the document is printed from a viewer application.
 *
 * @return	None.
 */
-(void)set: (NSString*)subtype printState: (FSLayerUsageState)printState;
/** @brief	Set a UTF-8 encoding string, specifying the kind of content controlled by the group.*/
-(void)setSubtype: (NSString*)value;
/** @brief	Get a UTF-8 encoding string, specifying the kind of content controlled by the group.*/
-(NSString*)getSubtype;
/**
 * @brief	Layer usage state, indicating that the group should be set to which state when the document is printed from a viewer application.
 *
 * @param[in]	value		Layer usage state, indicating that the group should be set to which state when the document is printed from a viewer application.
 * @details	Please refer to {@link FSLayerUsageState::e_layerStateON FSLayerUsageState::e_layerStateXXX} values and it should be one of these values
 *			except {@link FSLayerUsageState::e_layerStateUnchanged}.
 */
-(void)setPrintState: (FSLayerUsageState)value;
/** @brief	Get layer usage state. */
-(FSLayerUsageState)getPrintState;
/** @brief Free the object. */
-(void)dealloc;

@end

NS_ASSUME_NONNULL_END
