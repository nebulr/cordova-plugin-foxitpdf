/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFAnnot.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * @brief	Enumeration for PDF annotation type.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotType) {
    /** @brief	Annotation type: unknown.*/
    e_annotUnknownType= 0,
    /** @brief	Annotation type: note annotation, which is just "Text" annotation defined in <PDF reference 1.7>.*/
    e_annotNote,
    /** @brief	Annotation type: link annotation.*/
    e_annotLink,
    /** @brief	Annotation type: free text annotation.*/
    e_annotFreeText,
    /** @brief	Annotation type: line annotation.*/
    e_annotLine,
    /** @brief	Annotation type: square annotation.*/
    e_annotSquare,
    /** @brief	Annotation type: circle annotation.*/
    e_annotCircle,
    /** @brief	Annotation type: polygon annotation.*/
    e_annotPolygon,
    /** @brief	Annotation type: polyline annotation.*/
    e_annotPolyLine,
    /** @brief	Annotation type: highlight annotation.*/
    e_annotHighlight,
    /** @brief	Annotation type: underline annotation.*/
    e_annotUnderline,
    /** @brief	Annotation type: squiggly annotation.*/
    e_annotSquiggly,
    /** @brief	Annotation type: strikeout annotation.*/
    e_annotStrikeOut,
    /** @brief	Annotation type: stamp annotation.*/
    e_annotStamp,
    /** @brief	Annotation type: caret annotation.*/
    e_annotCaret,
    /** @brief	Annotation type: ink annotation.*/
    e_annotInk,
    /** @brief	Annotation type: pressure sensitive ink annotation.*/
    e_annotPSInk,
    /** @brief	Annotation type: file attachment annotation.*/
    e_annotFileAttachment,
    /** @brief	Annotation type: sound annotation.*/
    e_annotSound,
    /** @brief	Annotation type: movie annotation.*/
    e_annotMovie,
    /** @brief	Annotation type: widget annotation.*/
    e_annotWidget,
    /** @brief	Annotation type: screen annotation.*/
    e_annotScreen,
    /** @brief	Annotation type: printer's mark annotation.*/
    e_annotPrinterMark,
    /** @brief	Annotation type: trap network annotation.*/
    e_annotTrapNet,
    /** @brief	Annotation type: watermark annotation.*/
    e_annotWatermark,
    /** @brief	Annotation type: 3D annotation.*/
    e_annot3D,
    /** @brief	Annotation type: pop-up annotation.*/
    e_annotPopup
};

/**
 * @brief	Enumeration for PDF annotation flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSAnnotFlags) {
    /** @brief	Annotation flag: invisible */
    e_annotFlagInvisible = 1 << 0,
    /** @brief	Annotation flag: hidden */
    e_annotFlagHidden =    1 << 1,
    /** @brief	Annotation flag: print */
    e_annotFlagPrint =     1 << 2,
    /** @brief	Annotation flag: no zoom */
    e_annotFlagNoZoom =    1 << 3,
    /** @brief	Annotation flag: no rotate */
    e_annotFlagNoRotate =  1 << 4,
    /** @brief	Annotation flag: no view */
    e_annotFlagNoView =    1 << 5,
    /** @brief	Annotation flag: read only */
    e_annotFlagReadOnly =  1 << 6,
    /** @brief	Annotation flag: locked */
    e_annotFlagLocked =    1 << 7,
    /** @brief	Annotation flag: toggle no view */
    e_annotFlagToggleNoView = 1 << 8,
    /** @brief	Annotation flag: locked contents */
    e_annotFlagLockedContents = 1 << 9
};

/**
 * @brief	Enumeration for PDF annotation border style.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSBorderStyle) {
    /** @brief	Border style: Solid */
    e_borderStyleSolid = 0,
    /**
     * @brief	Border style: Dashed.
     *
     * @details	This is only useful for link, free text, line, square, circle, polygon, and polyline annotation.
     *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FSBorderStyle::e_borderStyleSolid} by default internally.
     */
    e_borderStyleDashed,
    /**
     * @brief	Border style: Underline.
     *
     * @details	This is only useful for link annotation.
     *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FSBorderStyle::e_borderStyleSolid} by default internally.
     */
    e_borderStyleUnderLine,
    /**
     * @brief	Border style: Beveled.
     *
     * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
     *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FSBorderStyle::e_borderStyleSolid} by default internally.
     */
    e_borderStyleBeveled,
    /**
     * @brief	Border style: Inset.
     *
     * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
     *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FSBorderStyle::e_borderStyleSolid} by default internally.
     */
    e_borderStyleInset,
    /**
     * @brief	Border style: Cloudy.
     *
     * @details	This is only useful for free text, square, circle, and polygon annotations.
     *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FSBorderStyle::e_borderStyleSolid} by default internally.
     */
    e_borderStyleCloudy
};

/**
 * @brief	Enumeration for PDF annotation highlighting mode.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSHighLightingMode) {
    /** @brief	Highlighting mode: None. */
    e_highlightingModeNone = 0,
    /** @brief	Highlighting mode: Invert */
    e_highlightingModeInvert,
    /** @brief	Highlighting mode: Outline */
    e_highlightingModeOutline,
    /** @brief	Highlighting mode: Push */
    e_highlightingModePush,
    /** @brief	Highlighting mode: Toggle. This is only useful for widget annotation. */
    e_highlightingModeToggle
};

/**
 * @brief Enumeration for alignments(horizontal).
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAlignment) {
    /** @brief Left alignment.*/
    e_alignmentLeft,
    /** @brief Center alignment.*/
    e_alignmentCenter,
    /** @brief Righte alignment.*/
    e_alignmentRight
};

/**
 * @brief Enumeration for annotation's MK dictionary (an appearance characteristics) entry.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotMKEntry) {
    /** @brief Rotation entry. "R" in MK dictionary. */
    e_mkEntryRotation = 0,
    /** @brief Border color entry. "BC" in MK dictionary. */
    e_mkEntryBorderColor = 1,
    /** @brief Background color entry. "BG" in MK dictionary. */
    e_mkEntryBackgroundColor = 2,
    /**
     * @brief Normal caption entry. "CA" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field, check box field or radio button field.
     */
    e_mkEntryNormalCaption = 3,
    /**
     * @brief Rollover caption entry. "RC" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryRolloverCaption = 4,
    /**
     * @brief Down caption (or alternate caption) entry. "AC" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryDownCaption = 5,
    /**
     * @brief Normal icon entry. "I" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryNormalIcon = 6,
    /**
     * @brief Rollover icon entry. "RI" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryRolloverIcon = 7,
    /**
     * @brief Down icon (or alternate icon) entry. "IX" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryDownIcon = 8,
    /**
     * @brief Icon fit information entry. "IF" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     */
    e_mkEntryIconFit = 9,
    /**
     * @brief Icon and caption relation entry. "TP" in MK dictionary.
     *
     * @note Only applicable for widget annotation associated with pushbutton field.
     *       This is used to specify where to position the text of widget annotation's mk caption
     *       relative to widget annotation's mk icon.
     */
    e_mkEntryIconCaptionRelation = 10
};

/**
 * @brief Enumeration for icon and caption relative position in annotation's MK dictionary.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotMKIconCaptionRelation) {
    /** @brief No icon; captin only. */
    e_mkRelationNoIcon = 0,
    /** @brief No caption; icon only. */
    e_mkRelationNoCaption = 1,
    /** @brief Caption below the icon. */
    e_mkRelationCaptionBelowIcon = 2,
    /** @brief Caption above the icon. */
    e_mkRelationCaptionAboveIcon = 3,
    /** @brief Caption to the right of the icon. */
    e_mkRelationCaptionRight = 4,
    /** @brief Caption to the left of the icon. */
    e_mkRelationCaptionLeft = 5,
    /** @brief Caption overlaid directly on the icon. */
    e_mkRelationCaptionOvrlayOnIcon = 6
};

/**
 * @brief	Class to access a PDF annotation.
 *
 * @details	An annotation associates an object such as a note, sound, or movie with a location
 *			on a page of a PDF document, or provides a way to interact with the user by
 *			means of the mouse and keyboard. PDF includes a wide variety of standard annotation types.<br>
 *			Class ::FSAnnot is the base class for all kinds of PDF annotations. It offers the base functions
 *			to access annotation's common properties, to move an annotation or reset appearance stream of an annotation.
 *			For concrete annotation types, please refer to derived classes.
 *			To get the count of annotations or get/add/remove an annotation, please refer to class ::FSPDFPage.<br>
 *			Specially, for widget annotation, Foxit PDF SDK treats it as a form control, so the drived class for widget annot is class ::FSFormControl.<br>
 *
 * @note	Currently, following kind of functions only support note, highlight, underline, strikeout, squiggly, link,
 *			square, circle, free text, stamp, caret, ink, line, polygon, polyline, file attachment, popup, widget annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSAnnot.</li>
 *			<li>2. Functions {@link FSAnnot::move:}, {@link FSAnnot::resetAppearanceStream}, {@link FSAnnot::removeProperty:}.
 *				   Specially, when the widget annotatoin represents as a signature field, {@link FSAnnot::resetAppearanceStream} does not support it.
 *			</li>
 *			</ul>
 *
 * @see	FSPDFPage
 * @see	FSFormControl
 */
@interface FSAnnot : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the related PDF page.
 *
 * @return	The related PDF page instance.
 *			Do not call function {@link FSPDFDoc::closePage:} for the returned page instance.
 */
-(FSPDFPage*)getPage;
/**
 * @brief	Check if current annotation is a markup annotation.
 *
 * @return	<b>YES</b> means current annotation is a markup annotation, while <b>NO</b> means current annotation is not a markup annotation.
 */
-(BOOL)isMarkup;
/**
 * @brief	Get actual annotation type of current annotation.
 *
 * @return	Annotation type.
 *			Please refer to {@link FSAnnotType::e_annotNote FSAnnotType::e_annotXXX} values and it would be one of these values.
 */
-(FSAnnotType)getType;
/**
 * @brief	Get the index of current annotation, in the page which current annotation belongs to.
 *
 * @return	The index value, starting from 0.
 *			If there is any error, -1 would be returned.
 */
-(int)getIndex;
/**
 * @brief	Get content.
 *
 * @return	Content string.
 */
-(NSString *)getContent;
/**
 * @brief	Set content.
 *
 * @param[in]	content		New content string to be set.
 */
-(void)setContent: (NSString *)content;
/**
 * @brief	Get last modification date time.
 *
 * @return	A date time instance that receives the last modified date time.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set last modification date time.
 *
 * @param[in]	dataTime		The data time to be set. It should contain valid date time data.
 */
-(void)setModifiedDateTime: (FSDateTime*)dataTime;
/**
 * @brief	Get annotation flags.
 *
 * @return	The annotation flags.
 *			Please refer to {@link FSAnnotFlags::e_annotFlagInvisible FSAnnotFlags::e_annotFlagXXX} values and it would be one or a combination of them.
 *			0 means no annotation flag.
 */
-(FSAnnotFlags)getFlags;
/**
 * @brief	Set annotation flags.
 *
 * @param[in]	flags	The annotation flags.
 *						It could be 0, or one or a combination of {@link FSAnnotFlags::e_annotFlagInvisible FSAnnotFlags::e_annotFlagXXX} values.
 */
-(void)setFlags: (FSAnnotFlags)flags;
/**
 * @brief	Get unique ID.
 *
 * @return	Unique ID string.
 */
-(NSString *)getUniqueID;
/**
 * @brief	Set unique ID.
 *
 * @param[in]	uniqueID		New unique ID string to be set.
 */
-(void)setUniqueID: (NSString *)uniqueID;
/**
 * @brief	Get rectangle, in PDF coordinate system.
 *
 * @return	Annotation's rectangle, in PDF coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectF*)getRect;
/**
 * @brief	Move current annotation to a new position, specified by a new rectangle in PDF coordinate system.
 *
 * @param[in]	rect	New rectangle to specify the new position where current annotation is to be moved to.
 *						It should be valid in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)move: (FSRectF*)rect;
/**
 * @brief	Get border information.
 *
 * @details	For an annotation which does not have border information, the default border information will be returned:<br>
 *			{@link FSBorderInfo::getWidth} = 1, {@link FSBorderInfo::getStyle} = e_borderStyleSolid, {@link FSBorderInfo::getCloudIntensity} = 0,
 *			{@link FSBorderInfo::getDashPhase} = 0, dashes array of {@link FSBorderInfo} is <b>nil</b>.
 *
 * @return	A ::FSBorderInfo object that received the border information.
 *			If not find any border information, the default border information will be returned as described in "Details" part.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSBorderInfo*)getBorderInfo;
/**
 * @brief	Set border information.
 *
 * @param[in]	border		New border information to be set. It should be a valid ::FSBorderInfo object.
 *							If any value of parameter <i>border</i> is invalid, this function will fail to set new border information to current annotation.
 */
-(void)setBorderInfo: (FSBorderInfo*)border;
/**
 * @brief	Get border color.
 *
 * @return	The border color. Format: 0xRRGGBB.
 *			If no border color can be found or any error occurs, 0x000000 will be returned.
 */
-(unsigned int)getBorderColor;
/**
 * @brief	Set border color.
 *
 * @param[in]	color		New border color to be set. Format: 0xRRGGBB.
 */
-(void)setBorderColor: (unsigned int)color;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get annotation rectangle in device coordinate system.
 *
 * @details	This is a useful function to get the device rectangle of an annotation, but not support pop-up annotation.<br>
 *			For the rectangle conversion, the result rectangle is always "normalized",
 *			which is based on device coordinate system: left is always smaller than right, and top is always smaller than bottom.
 *
 * @param[in]	isTransformIcon	A boolean value which indicates that whether to transform (like rotate or scale) the icon with page:
 *								<b>YES</b> means to transform icon's rectangle with page,
 *								while <b>NO</b> means not transform icon's rectangle with page.<br>
 *								This parameter only affects on "Text" and "FileAttachment" annotations, because they are shown as icon.
 * @param[in]	matrix			A matrix used to transform from PDF coordinate system to device coordinate system.
 *								Usually, this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:} and also used for rendering.
 *
 * @return	A rectangle in device coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectI*)getDeviceRect: (BOOL)isTransformIcon matrix: (FSMatrix*)matrix;
/**
 * @brief	Get annotation's dictionary.
 *
 * @return	Annotation's dictionary.
 */
-(FSPDFDictionary*)getDict;
/**
 * @brief	Remove a specified annotation's property.
 *
 * @details	This function can be used to remove some optional properties of an annotation.
 *
 * @param[in]	property	Property name. Please refer to {@link FSM_ANNOTPROPERTY::e_annotPropertyModifiedDate FSM_ANNOTPROPERTY::e_annotPropertyXXX} values
 *							and it should be one of these values.
 *
 * @return	<b>YES</b> means remove the specified property successfully, or current annotation supports the property but does not have the property.
 *			<b>NO</b> means current annotation does not support to have the specified property, current annotation cannot be modified or failure.
 */
-(BOOL)removeProperty: (FSAnnotProperty)property;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent annotation border information.
 *
 * @details	This class offers functions to access PDF annotation border information,
 *			such as border width, border style and so on.
 *			This class is used for functions {@link FSAnnot::getBorderInfo} and {@link FSAnnot::setBorderInfo:}.
 *
 * @see FSAnnot
 */
@interface FSBorderInfo : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief Set value.
 *
 * @param[in] width       Border width, in points. This should be a non-negative value.
 *                        If this value is 0, no border is drawn.
 * @param[in] style       Border style. Please refer to
 *                        {@link FSBorderStyle::e_borderStyleSolid FSBorderStyle::e_borderStyleXXX} values and it should
 *                        be one of these values.
 * @param[in] intensity   Intensity of the cloudy effect. Only useful when parameter <i>style</i> is
 *                        {@link FSBorderStyle::e_borderStyleCloudy FSBorderStyle::e_borderStyleCloudy}.
 *                        Valid value range: 0 to 2. 0 means no cloudy border effect.<br>
 *                        If the value is below 0, it will have the same effect as value 0.
 *                        If the value is above 2, it will have the same effect as value 2.
 * @param[in] dashPhase  Dash phase. Only useful when parameter <i>style</i> is
 *                        {@link FSBorderStyle::e_borderStyleDashed FSBorderStyle::e_borderStyleDashed}.
 * @param[in] dashes      A dash array that represents the dash patterns. The value of each element in this array
 *                        should not be negative. Only useful when FSBorderInfo::style is
 *                        {@link FSBorderStyle::e_borderStyleDashed FSBorderStyle::e_borderStyleDashed}.
 * @param[in] dashCount  The count of elements in dash array. Only useful when FSBorderInfo::style is
 *                        {@link FSBorderStyle::e_borderStyleDashed FSBorderStyle::e_borderStyleDashed}.
 *
 * @return None.
 */
-(void)set: (float)width style: (FSBorderStyle)style intensity: (float)intensity dashPhase: (float)dashPhase dashes: (NSArray<NSNumber *> *)dashes;
/**
 * @brief	Set border width, in points.
 *
 * @param[in]	value	Border width. This value should not be negative.
 *						If this value is 0, no border will be drawn.
 */
-(void)setWidth: (float)value;
/**
 * @brief	Get border width, in points.
 *
 * @return	Border width. It would be non-negative.
 *			0 means no border will be drawn.
 */
-(float)getWidth;
/**
 * @brief	Set border style.
 *
 * @param[in]	value	Border style.
 *						Please refer to enumeration {@link FSBorderStyle::e_borderStyleSolid FSBorderStyle::e_borderStyleXXX} and this should be one of its values.
 *						Please also check comment of these values for more details.
 */
-(void)setStyle: (FSBorderStyle)value;
/**
 * @brief	Get border style.
 *
 * @return	Border style.
 *			Please refer to enumeration {@link FSBorderStyle::e_borderStyleSolid FSBorderStyle::e_borderStyleXXX} and this should be one of its values.
 */
-(FSBorderStyle)getStyle;
/**
 * @brief	set intensity of the cloudy effect.
 *
 * @details	This is only useful to free text, square, circle, and polygon annotations 
 *			when FSBorderInfo::getStyle is {@link FSM_BORDERSTYLE::e_borderStyleCloudy}.<br>
 *			Suggested value range: 0 to 2. 0 means no cloudy border effect. <br>
 *			For rest value, their effect would be:
 *			<ul>
 *			<li>If the value is below 0, it will have the same effect as value 0. </li>
 *			<li>If the value is above 2, it will have the same effect as value 2.</li>
 *			</ul>
 * @param[in]	value	Intensity of the cloudy effect. Valid value range: 0 to 2.
 *						-1 mean no cloudy border effect.<br>
 */
-(void)setCloudIntensity: (float)value;
/**
 * @brief	Get intensity of the cloudy effect.
 *
 * @details	Intensity of the cloudy effect is only useful to free text, square, circle, polygon, and polyline annotations
 *			when FSBorderInfo::getStyle is {@link FSBorderStyle::e_borderStyleCloudy}.
 *
 * @return	Intensity of the cloudy effect. Valid value range: 0 to 2.
 *			-1 mean no cloudy border effect.<br>
 */
-(float)getCloudIntensity;
/**
 * @brief	Set dash phase.
 *
 * @details	Dash phase is only useful when FSBorderInfo::getStyle is {@link FSBorderStyle::e_borderStyleDashed}.
 *             The value of useful elements in this array should not be negative.<br>
 *			In this array, an element with integer value -1 means that all the elements before this element are useful,
 *			and this element with the rest will be ignored.<br>
 *			If no element's value is -1, that means all of 16 elements are useful.
 *
 * @param[in]	value	New dash phase.
 */
-(void)setDashPhase: (float)value;
/**
 * @brief	Get dash phase.
 *
 * @details	Dash phase is only useful when FSBorderInfo::getStyle is {@link FSBorderStyle::e_borderStyleDashed}.
 *
 * @return	Dash phase.
 */
-(float)getDashPhase;
/**
 * @brief	Set dash pattern array.
 *
 * @details	Dashes array is only useful when FSBorderInfo::getStyle is {@link FSBorderStyle::e_borderStyleDashed}.
 *          The value of elements in this array should not be negative.<br>
 *
 * @param[in]	value	New dash pattern array, with float values.
 *						The value of elements in this array should not be negative.<br>
 *						<b>nil</b> means no dash pattern array is needed.
 */
-(void)setDashes: (NSArray<NSNumber *> *)value;
/**
 * @brief	Get dash pattern array.
 *
 * @details	Dashes array is only useful when FSBorderInfo::getStyle is {@link FSBorderStyle::e_borderStyleDashed}.
 *
 * @return	Dashes array, with elements of non-negative values.
 *			<b>nil</b> means no dash pattern array.
 */
-(NSArray<NSNumber *> *)getDashes;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a quadrilateral, in PDF coordinate system.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *			This class offers functions to access points values of a quadrilateral.
 */
@interface FSQuadPoints : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	first		First point of the quadrilateral, in PDF coordinate system.
 * @param[in]	second		Second point of the quadrilateral, in PDF coordinate system.
 * @param[in]	third		Third point of the quadrilateral, in PDF coordinate system.
 * @param[in]	fourth		Fourth point of the quadrilateral, in PDF coordinate system.
 */
-(void)set: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth;
/**
 * @brief	Set first point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	First point to be set.
 */
-(void)setFirst: (FSPointF*)value;
/**
 * @brief	Get first point of quadrilateral, in PDF coordinate system.
 *
 * @return	First point value.
 */
-(FSPointF*)getFirst;
/**
 * @brief	Set second point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	Second point to be set.
 */
-(void)setSecond: (FSPointF*)value;
/**
 * @brief	Get second point of quadrilateral, in PDF coordinate system.
 *
 * @return	Second point value.
 */
-(FSPointF*)getSecond;
/**
 * @brief	Set third point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	Third point to be set.
 */
-(void)setThird: (FSPointF*)value;
/**
 * @brief	Get third point of quadrilateral, in PDF coordinate system.
 *
 * @return	Third point value.
 */
-(FSPointF*)getThird;
/**
 * @brief	Set fourth point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	Fourth point to be set.
 */
-(void)setFourth: (FSPointF*)value;
/**
 * @brief	Get fourth point of quadrilateral, in PDF coordinate system.
 *
 * @return	Fourth point value.
 */
-(FSPointF*)getFourth;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent shading color.
 *
 * @details	This class represents colors used for Type 2 (Axial) Shadings.
 *			It offers functions to access the 2 colors used for Type 2 (Axial) Shadings.
 */
@interface FSShadingColor : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	firstColor		First color used for shading. Format: 0xAARRGGBB.
 * @param[in]	secondColor		Second color used for shading. Format: 0xAARRGGBB.
 */
-(void)set: (unsigned int)firstColor secondColor: (unsigned int)secondColor;
/**
 * @brief	Set first color used for shading.
 *
 * @param[in]	value	First color to be set. Format: 0xAARRGGBB.
 */
-(void)setFirstColor: (unsigned int)value;
/**
 * @brief	Get first color used for shading.
 *
 * @return	First color. Format: 0xAARRGGBB.
 */
-(unsigned int)getFirstColor;
/**
 * @brief	Set second color used for shading.
 *
 * @param[in]	value	Second color to be set. Format: 0xAARRGGBB.
 */
-(void)setSecondColor: (unsigned int)value;
/**
 * @brief	Get second color used for shading.
 *
 * @return	Second color. Format: 0xAARRGGBB.
 */
-(unsigned int)getSecondColor;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to represent a callback object as customized annotation icon provider.
 *
 * @details	All the functions int this class are used as callback functions and should be implemented by user.
 *			Icon provider can only be used for note, file attachment, stamp annotations.
 *			Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers
 *			by callback functions {@link FSAnnotIconProviderCallback::getProviderID} and {@link FSAnnotIconProviderCallback::getProviderVersion}.
 */
@interface FSAnnotIconProviderCallback : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** @brief Default initialization. */
-(id)init;
/**
 * @brief	A callback function used to get provider ID.
 *
 * @details	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers.
 *
 * @return	The provider ID string.
 */
-(NSString *)getProviderID;
/**
 * @brief	A callback function used to get provider version.
 *
 * @details	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers.
 *
 * @return	Version string.
 */
-(NSString *)getProviderVersion;
/**
 * @brief	A callback function used to check if current icon provider supports icon for a specified type.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports the specific icon,
 *			while <b>NO</b> means not support.
 */
-(BOOL)hasIcon: (FSAnnotType)annotType iconName: (NSString *)iconName;
/**
 * @brief	A callback function used to check if current icon provider supports to change color for a specified type.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports to change color for a specific icon type,
 *			while <b>NO</b> means not support.
 */
-(BOOL)canChangeColor: (FSAnnotType)annotType iconName: (NSString *)iconName;
/**
 * @brief	A callback function used to get the icon as PDF page contents for a specified type.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	color		The annotation icon color. Format: 0xAARRGGBB.
 *
 * @return	A page instance, whose content would be used as the icon.
 */
-(FSPDFPage*)getIcon: (FSAnnotType)annotType iconName: (NSString *)iconName color: (unsigned int)color;
/**
 * @brief	A callback function used to get the shading colors if current icon provider supports for a specified type.
 *			Currently, only support Type-2 shading settings with two color values.
 *
 * @param[in]	annotType		The annotation type.
 *								It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName		The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	refColor		Referenced color. Format: 0xAARRGGBB and alpha component is ignored.
 * @param[in]	shadingIndex	Index color of shading, starting from 0. If shading colors are more than one, this function will be called multiple times.
 *
 * @return	The two shading color value.
 *			If there is any error, implementation of this function should return <b>nil</b>.
 */
-(FSShadingColor*)getShadingColor: (FSAnnotType)annotType iconName: (NSString *)iconName refColor: (unsigned int)refColor shadingIndex: (int)shadingIndex;
/**
 * @brief	A callback function used to get the width for display of a specified icon, in device size(pixel normally).
 *
 * @details	This can be triggered during rendering process only when
 *			function {@link FSRenderer::setTransformAnnotIcon:} is called with value <b>NO</b> before rendering.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The width for display.
 */
-(NSNumber*)getDisplayWidth: (FSAnnotType)annotType iconName: (NSString *)iconName;
/**
 * @brief	A callback function used to get the height for display of a specific icon, in device size(pixel normally).
 *
 * @details	This can be triggered during rendering process only when
 *			function {@link FSRenderer::setTransformAnnotIcon:} is called with value <b>NO</b> before rendering.
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FSAnnotType::e_annotNote}, {@link FSAnnotType::e_annotFileAttachment} and {@link FSAnnotType::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The height for display.
 */
-(NSNumber*)getDisplayHeight: (FSAnnotType)annotType iconName: (NSString *)iconName;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a caret annotation.
 *
 * @details	A pop-up annotation (PDF 1.3) displays text in a pop-up window for entry and editing.
 *			It typically does not appear alone but is associated with a markup annotation, its parent annotation, and is used for editing the parent's text. <br>
 *			It has no appearance stream or associated actions of its own, so function {@link FSAnnot::resetAppearanceStream} will always return <b>NO</b> for a pop-up annotation.
 *			Class ::FSPopup is derived from class ::FSAnnot and also offers functions to access pop-up annotation's properties.
 *
 * @see	FSAnnot
 */
@interface FSPopup : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get open status.
 *
 * @details	Open status is a boolean value that specifies whether a pop-up annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @return	Open status:
 *			<ul>
 *			<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *			</ul>
 */
-(BOOL)getOpenStatus;
/**
 * @brief	Set open status.
 *
 * @details	Open status is a boolean value that specifies whether a pop-up annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @param[in]	status	The new open status value:
 *				<ul>
 *				<li><b>YES</b> means the pop-up annotation should be initially be displayed open.</li>
 *				<li><b>NO</b> means the pop-up annotation should be initially be displayed closed.</li>
 *				</ul>
 */
-(void)setOpenStatus:(BOOL)status;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a markup annotation.
 *
 * @details	Markup annotations are are used primarily to mark up PDF documents. These annotations have
 *			text that appears as part of the annotation and may be displayed in other ways by
 *			a viewer application, such as in a Comments pane.<br>
 *			Class ::FSMarkup is derived from class ::FSAnnot, and is also the base class for all PDF markup annotations.
 *			It offers the base functions to access markup annotation's common properties.
 *			For concrete markup annotation types, please refer to derived classes. <br>
 *			Function {@link FSAnnot::isMarkup} can be used to judge if an annotation is a markup annotation.
 *
 * @note	Currently, following kind of functions only support note, highlight, underline, strikeout, squiggly,
 *			square, circle, free text, stamp, caret, ink, line, polygon, polyline, file attachment annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSMarkup.</li>
 *			<li>2. Function {@link FSMarkup::resetAppearanceStream}.</li>
 *			</ul>
 *
 * @see	FSAnnot
 */
@interface FSMarkup : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Get related pop-up annotation.
 *
 * @details	Most markup annotations can have a pop-up annotation to show their content, except sound and free text annotations.<br>
 *			For sound annotation, it does not have a pop-up annotation.<br>
 *			For free text annotation, it shows text directly on the page, so no need to have a pop-up annotation. <br>
 *			Though, in some special(or error) PDF document, sound or free text annotation may have a pop-up annotation, they still do not need a pop-up
 *             annotation.<br>
 *
 * @return	The related pop-up annotation. <br>
 *			If current markup annotation does not have a pop-up annotation, this function will return <b>nil</b>.
 */
-(FSPopup*)getPopup;
/**
 * @brief	Set related pop-up annotation.
 *
 * @details	Most markup annotations can have a pop-up annotation to show their content, except sound and free text annotations.<br>
 *			For sound annotation, it does not have a pop-up annotation.<br>
 *			For free text annotation, it shows text directly on the page, so no need to have a pop-up annotation.<br>
 *			So, this function does not allow to set pop-up annotation to sound and free text annotation.
 *
 * @param[in]	popup	The new related popup annotation. It should not be <b>nil</b>.
 */
-(void)setPopup:(FSPopup*)popup;
/**
 * @brief	Get title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/**
 * @brief	Set title string.
 *
 * @param[in]	title		New title string to be set.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get subject.
 *
 * @return	Subject string.
 */
-(NSString *)getSubject;
/**
 * @brief	Set subject.
 *
 * @param[in]	subject		New subject string to be set.
 */
-(void)setSubject: (NSString *)subject;
/**
 * @brief	Get opacity.
 *
 * @return	The opacity value. Valid range: from 0.0 to 1.0.
 */
-(float)getOpacity;
/**
 * @brief	Set opacity.
 *
 * @param[in]	opacity		The new opacity value. Valid range: 0.0 to 1.0 .
 */
-(void)setOpacity: (float)opacity;
/**
 * @brief	Get intent name.
 *
 * @details	Following annotation types have predefined intent name:<br>
 *			<ul>
 *			<li>Free text annotation's predefined intent name: "FreeTextCallout", "FreeTextTypewriter".
 *				If no intent name is used, free text annotation would be shown as a text box.
 *			</li>
 *			<li>Line annotation's predefined intent name: "LineArrow", "LineDimension".
 *				If no intent name is used, line annotation would be shown as a common line.
 *			</li>
 *			<li>Polygon's predefined intent name: "PolygonCloud", "PolygonDimension".
 *				If no intent name is used, polygon annotation would be shown as a common polygon.
 *			</li>
 *			<li>Polyline annotation's predefined intent name: "PolyLineDimension".
 *				If no intent name is used, polyline annotation would be shown as a common polyline.
 *			</li>
 *			</ul>
 *
 * @return	The intent name string, in UTF-8 encoding.
 */
-(NSString *)getIntent;
/**
 * @brief	Set intent name.
 *
 * @details	Following annotation types have predefined intent name:<br>
 *			<ul>
 *			<li>Free text annotation's predefined intent name: "FreeTextCallout", "FreeTextTypewriter".
 *				If no intent name is used, free text annotation would be shown as a text box.
 *			</li>
 *			<li>Line annotation's predefined intent name: "LineArrow", "LineDimension".
 *				If no intent name is used, line annotation would be shown as a common line.<br>
 *				Currently, not support to set "LineDimension" as a line annotation's intent.
 *			</li>
 *			<li>Polygon's predefined intent name: "PolygonCloud", "PolygonDimension".
 *				If no intent name is used, polygon annotation would be shown as a common polygon.<br>
 *				Currently, not support to set "PolygonDimension" as a polygon annotation's intent.<br>
 *				If a polygon annotation's intent is to be set to "PolygonCloud", the polygon annotation's border style will be changed to
 *				{@link FSM_BORDERSTYLE::e_borderStyleCloudy} and FSBorderInfo::getCloudIntensity will be set to 2 by default.
 *			</li>
 *			<li>Polyline annotation's predefined intent name: "PolyLineDimension".
 *				If no intent name is used, polyline annotation would be shown as a common polyline.<br>
 *				Currently, not support to set "PolyLineDimension" as a polyline annotation's intent.
 *			</li>
 *			</ul>
 *
 * @param[in]	intent		New intent name string to be set.
 *							If it is <b>nil</b> or an empty string, that means the intent property will not be used.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 *							Some annotation type have predefined intent name, please refer to "Details" part for more details.
 *							If this string is one of those unsupported intent name, this string will be ignored when set to related annotations.
 */
-(void)setIntent: (NSString *)intent;
/**
 * @brief	Get creation date time.
 *
 * @return	A date time instance.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Set creation date time.
 *
 * @param[in]	dateTime	The new date time to be set.
 */
-(void)setCreationDateTime: (FSDateTime*)dateTime;
/**
 * @brief	Count all replies.
 *
 * @return	The count of replies.
 */
-(int)getReplyCount;
/**
 * @brief	Get a reply by index.
 *
 * @param[in]	index	The index for a specified reply. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	A note annotation instance which is used as a reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)getReply: (int)index;
/**
 * @brief	Add a reply to the end of reply list.
 *
 * @return	A new note annotation instance which is used as the new reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)addReply;
/**
 * @brief	Remove a reply by index.
 *
 * @details	If specific reply has its own replies, these sub replies will be removed at the same time.
 *
 * @param[in]	index	The index for a specified reply to be removed. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeReply: (int)index;
/**
 * @brief	Remove all replies.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAllReplies;
/**
 * @brief	Check whether current markup annotation is in a group or not.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	<b>YES</b> means current markup annotation is in a group.
 *			<b>NO</b> means current markup annotation does not belong to any group.
 */
-(BOOL)isGrouped;

/**
 * @brief	Get the header annotation (as primary annotation) of the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	The header markup annotation of the group that current markup annotation belongs to.
 *			If current annotation does not belong to a group or there is any error, this function will return <b>nil</b>.
 */
-(FSMarkup*)getGroupHeader;

/**
 * @brief	Count the elements in the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @return	The count of elements in the group that current markup annotation belongs to.
 */
-(int)getGroupElementCount;

/**
 * @brief	Get an element (as markup annotation) from the group that current markup annotation belongs to.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @param[in]	index		The index of the element to be retrieved. Valid range: from 0 to (<i>count</i> - 1).
 *							<i>count</i> is returned by function {@link FSMarkup::getGroupElementCount}.
 *
 * @return	The markup annotation from the group, specified by index.
 *			If current annotation does not belong to a group or there is any error, this function will return <b>nil</b>.
 */
-(FSMarkup*)getGroupElement : (int)index;

/**
 * @brief	Ungroup current markup annotation from the group it belongs to.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means current markup annotation does not belong to any group or any other failure.
 */
-(BOOL)ungroup;

/**
 * @brief	Get the count of state annotations, under a specified state model.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FSAnnotStateModel::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FSAnnotStateModel::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...
 *
 * @param[in]	stateModel 	State model. It should be one of following values:
 *							<ul>
 *							<li>{@link FSAnnotStateModel::e_annotStateModelMarked}</li>
 *							<li>{@link FSAnnotStateModel::e_annotStateModelReview}</li>
 *							</ul>
 *
 * @return	The count of states for the specified state model.
 */
-(int)getStateAnnotCount: (FSAnnotStateModel)stateModel;

/**
 * @brief	Get a state annotation, under a specified state model.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FSAnnotStateModel::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FSAnnotStateModel::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...
 *
 * @param[in]	stateModel 	State model. It should be one of following values:
 *							<ul>
 *							<li>{@link FSAnnotStateModel::e_annotStateModelMarked}</li>
 *							<li>{@link FSAnnotStateModel::e_annotStateModelReview}</li>
 *							</ul>
 * @param[in]	index		The index of the state annotation to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSMarkup::getStateAnnotCount:} with the same parameter <i>stateModel</i>.
 *
 * @return	The state annotation, represented by a note annotation.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSNote*)getStateAnnot: (FSAnnotStateModel)stateModel index: (int)index;

/**
 * @brief	Add a new state annotation.
 *
 * @details	A markup annotation may have an author-specific state associated with it.
 *			The state is not specified in the annotation itself but in a separate text annotation
 *			that refers to the original annotation.<br>
 *			Usually, when state model is {@link FSAnnotStateModel::e_annotStateModelMarked}, the markup annotation only has one state annotation.<br>
 *			When state model is {@link FSAnnotStateModel::e_annotStateModelReview}, the markup annotation can have several state annotations in a chain:
 *			first state annotation refers to the markup annotation, second state annotation refers to the first state annotation, etc. Just like this:
 *			markup annotation <-- reviewed state1 <-- reviewed state2 ...<br>
 *
 * @param[in]	stateModel	State model for the new state annotation. It should be one of following values:
 *							<ul>
 *							<li>{@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked}:
 *								<ul>
 *								<li>If current markup annotation already has a state annotation in marked state model, this function will set the new state value
 *								the existed marked state model directly instead of adding a new one.
 *								</li>
 *								<li>If current markup annotation does not have a state annotation in marked state model, this function will add a new one.
 *								</li>
 *								</ul>
 *							</li>
 *							<li>{@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview}:
 *								<ul>
 *								<li>If current markup annotation already has state annotations in reviewed state model, this function will add a new one
 *									to refer to the last state annotation in reviewed state model.
 *								</li>
 *								<li>If current markup annotation does not have any state annotation in reviewed state model, this function will add a new one
 *									to refer to current markup annotation.
 *								</li>
 *								</ul>
 *							</li>
 *							</ul>
 * @param[in]	state		State value for the new state annotation. It should be one of following values:
 *							<ul>
 *							<li>If parameter <i>stateModel</i> is {@link FSAnnotStateModel::e_annotStateModelMarked}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateMarked} or {@link FSM_ANNOTSTATE::e_annotStateUnmarked}.
 *							</li>
 *							<li>If parameter <i>stateModel</i> is {@link FSAnnotStateModel::e_annotStateModelReview}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateAccepted}, {@link FSM_ANNOTSTATE::e_annotStateRejected}, {@link  FSM_ANNOTSTATE::e_annotStateCancelled},
 *								{@link FSM_ANNOTSTATE::e_annotStateCompleted}, or {@link FSM_ANNOTSTATE::e_annotStateNone}.
 *							</li>
 *							</ul>
 *
 * @return	A new state annotation, represented by a note annotation.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSNote*)addStateAnnot: (FSAnnotStateModel)stateModel state: (FSAnnotState)state;

/**
 * @brief	Remove all state annotations.
 *
 * @details	State annotation is represented by note annotation,
 *			so, to remove state annotations also means to remove the special note annotations (with its popup if any) from the page.
 *
 * @return	<b>YES</b> means remove all the state annotations successfully or current annotation does not have any state annotation,
 *			while <b>NO</b> means failure.<br>
 */
-(BOOL)removeAllStateAnnots;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a note annotation.
 *
 * @details	A note annotation (known as "text" annotation in <PDF reference 1.7>) represents a "sticky note"
 *			attached to a point in the PDF document. When closed, the annotation appears as an icon;
 *			when open, it displays a pop-up window containing the text of the note in a font and size
 *			chosen by the viewer application. <br>
 *			A note annotation can also be used as a reply to a markup annotation, or a state annotation:
 *			<ul>
 *			<li>When as a reply, the note annotation should not be shown alone but together with other replies in the form of threaded comments.
 *				Function {@link FSNote::getReplyTo} can be used to get the markup annotation, to which the note annotation replies.
 *			</li>
 *			<li>When as a state, the note annotation would not be shown alone.
 *				Function {@link FSNote::isStateAnnot} can be used to judge if a note annotation is used as a state.
 *			</li>
 *			</ul>
 *			Note annotation is a kind of markup annotation, so class ::FSNote is derived from class ::FSMarkup.
 *			It offers functions to access note annotation's properties and reset appearance of a note annotation.
 *
 * @note	For a newly created common note annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFFFF00 (yellow), opacity = 1.0, icon name = "Comment".
 *
 * @see	FSMarkup
 */
@interface FSNote : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @return	Open status.
 */
-(BOOL)getOpenStatus;
/**
 * @brief	Set open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @param[in]	status	The new open status value.
 */
-(void)setOpenStatus: (BOOL)status;
/**
 * @brief	Get icon name.
 *
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Check", "Circle", "Comment", "Cross", "Help",
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph",
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpLeftArrow".<br>
 *			An empty icon name string means current note annotation would be treated as "Note" icon.<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString *)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Check", "Circle", "Comment", "Cross", "Help",
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph",
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpLeftArrow".<br>
 *			An empty icon name string means current note annotation would be treated as "Note" icon.<br>
 *			For a newly created note annotation, if current function is not called, icon name will be "Comment" by default.
 *
 * @param[in]	iconName	New icon name string to be set.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName: (NSString *)iconName;
/**
 * @brief	Get the markup annotation, which current note annotation is in reply to.
 *
 * @details	This function is only useful when current note annotation is used as a reply.
 *
 * @return	A markup annotation object, which current note annotation is in reply to.
 *			If current note annotation is not used as a reply, this function will return <b>nil</b>.
 */
-(FSMarkup*)getReplyTo;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Check if current note annotation is used as a state annotation.
 *
 * @return	<b>YES</b> means current note annotation is used as a state annotation,
 *			while <b>NO</b> means current note annotation is just a common note annotation.
 */
-(BOOL)isStateAnnot;
/**
 * @brief	Get the state model.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this.
 *
 * @return	The state model.
 *			If function succeeds, the return value would be {@link FSAnnotStateModel::e_annotStateModelMarked} or {@link
 *              FSAnnotStateModel::e_annotStateModelReview}.<br>
 *			If current note annotation is not a state annotation or there is any error, this function will return 0.
 */
-(FSAnnotStateModel)getStateModel;
/**
 * @brief	Get the state.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this status.
 *
 * @return	The state.
 *			Please refer to {@link FSM_ANNOTSTATE::e_annotStateMarked FSM_ANNOTSTATE::e_annotStateXXX} values and it would be one of these values.
 *			If current note annotation is not a state annotation or there is any error, This function will return 0.
 */
-(FSAnnotState)getState;
/**
 * @brief	Set the state.
 *
 * @details	This function can only be used when current note annotation is used as a state annotation.
 *			Function {@link FSNote::isStateAnnot} can be used to check this.
 *
 * @param[in]	state		New state. It should be one of following values:
 *							<ul>
 *							<li>If state model is  {@link FSAnnotStateModel::e_annotStateModelMarked}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateMarked} or {@link FSM_ANNOTSTATE::e_annotStateUnmarked}.
 *							</li>
 *							<li>If state model is {@link FSAnnotStateModel::e_annotStateModelReview}, the state should be
 *								{@link FSM_ANNOTSTATE::e_annotStateAccepted}, {@link FSM_ANNOTSTATE::e_annotStateRejected}, {@link FSM_ANNOTSTATE::e_annotStateCancelled},
 *								{@link FSM_ANNOTSTATE::e_annotStateCompleted}, or {@link FSM_ANNOTSTATE::e_annotStateNone}.
 *							</li>
 *							</ul>
 *							State model can be gotten by function {@link FSNote::getStateModel}.
 */
-(void)setState: (FSAnnotState)state;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a text markup annotation.
 *
 * @details	Text markup annotations appear as highlights, underlines, strikeouts,
 *			or squiggly lines in the text of a document.<br>
 *			Text markup annotations are all markup annotations, so class ::FSTextMarkup is derived from class ::FSMarkup.
 *			It is the base class for all PDF text markup annotations. It offers the base functions
 *			to access text markup annotation's common properties. <br>
 *			Especially, for a text markup annotation, quadrilaterals are required. So please ensure that a text markup annotation
 *			has valid quadrilaterals before resetting its appearance stream. <br>
 *			For concrete text markup annotation types, please refer to derived classes.
 *
 * @see	FSMarkup
 */
@interface FSTextMarkup : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/**
 * @brief	Get a quadrilaterals by index.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSTextMarkup::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/**
 * @brief	Set quadrilaterals.
 *
 * @details	For a text markup annotation, quadrilaterals are required.
 *			After setting new quadrilaterals, rectangle of current text markup annotation will be updated as well. <br>
 *			The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 *
 * @param[in]	quadPoints		A valid quadrilateral array. It should contains at least one valid quadrilateral.
 */
-(void)setQuadPoints: (NSArray*)quadPoints;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a highlight annotation.
 *
 * @details	Highlight annotation is a kind of text markup annotation, which is shown as
 *			a highlight area for the text in a PDF document.
 *			Class ::FSHighlight is derived from ::FSTextMarkup and offers function to reset appearance stream of a highlight annotation.
 *			For a highlight annotation, quadrilaterals are required. So please ensure that a highlight annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created highlight annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFFED00 (a kind of yellow), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSHighlight : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a highlight annotation, please ensure this highlight annotation has valid quadrilaterals;
 *			otherwise this highlight annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a underline annotation.
 *
 * @details	Underline annotation is a kind of text markup annotation, which is shown as
 *			a underline under the text in a PDF document.
 *			Class ::FSUnderline is derived from ::FSTextMarkup and offers function to reset appearance stream of a underline annotation.
 *			For a underline annotation, quadrilaterals are required. So please ensure that a underline annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created underline annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFF339E00 (a kind of green), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSUnderline : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a underline annotation, please ensure this underline annotation has valid quadrilaterals;
 *			otherwise this underline annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a strikeout annotation.
 *
 * @details	Strikeout annotation is a kind of text markup annotation, which is shown as
 *			a strikeout line in the middle of the text in a PDF document.
 *			Class ::FSStrikeOut is derived from ::FSTextMarkup and offers function to reset appearance stream of a strikeout annotation.
 *			For a strikeout annotation, quadrilaterals are required. So please ensure that a strikeout annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created strikeout annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFF94244 (a kind of red), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSStrikeOut : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a strikeout annotation, please ensure this strikeout annotation has valid quadrilaterals;
 *			otherwise this strikeout annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a squiggly annotation.
 *
 * @details	Squiggly annotation is a kind of text markup annotation, which is shown as
 *			a squiggly line under the text in a PDF document.
 *			Class ::FSSquiggly is derived from ::FSTextMarkup and offers function to reset appearance stream of a squiggly annotation.
 *			For a squiggly annotation, quadrilaterals are required. So please ensure that a squiggly annotation
 *			has valid quadrilaterals before resetting its appearance stream.
 *
 * @note	For a newly created squiggly annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required quadrilaterals property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFF4899FF (a kind of blue), opacity = 1.0,
 *
 * @see	FSTextMarkup
 */
@interface FSSquiggly : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a squiggly annotation, please ensure this squiggly annotation has valid quadrilaterals;
 *			otherwise this squiggly annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a square annotation.
 *
 * @details	Square annotation is a rectangle on the page. Despite the name "square", a square annotation can represent either a square or a rectangle,
 *			which means the width and height of the annotation rectangle need not be equal.<br>
 *			Square annotation is a kind of markup annotation, so class ::FSSquare is derived from class ::FSMarkup, and also offers functions
 *			to access square annotation's properties and reset appearance stream of a square annotation.
 *
 * @note	For a newly created square annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid}.
 *
 * @see	FSMarkup
 */
@interface FSSquare : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setFillColor:(unsigned int)fillColor;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a square annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a square annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void) setInnerRect: (FSRectF*) innerRect;
/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a circle annotation.
 *
 * @details	Circle annotation is an ellipse on the page. Despite the name "circle", a circle annotation can represent either a circle or a oval,
 *			which means the width and height of the annotation rectangle need not be equal.<br>
 *			Circle annotation is a kind of markup annotation, so class ::FSCircle is derived from class ::FSMarkup, and also offers functions
 *			to access circle annotation's properties and reset appearance stream of a circle annotation.
 *
 * @note	For a newly created circle annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid}.
 *
 * @see	FSMarkup
 */
@interface FSCircle : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setFillColor:(unsigned int)fillColor;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a circle annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a circle annotation, inner rectangle means the actual boundaries of underlying circle.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void) setInnerRect: (FSRectF*) innerRect;
/*** @brief Free the object.*/
-(void)dealloc;

@end


/**
 * @brief	Class to access a link annotation.
 *
 * @details	A link annotation represents an action to be performed.<br>
 *			Class ::FSLink is derived from ::FSAnnot, and offers functions to access link annotation's properties
 *			and reset appearance stream of a link annotation.
 *
 * @note	For a newly created link annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any other properties, the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0,
 *			highlighting mode = {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeNone}.
 *
 * @see	FSAnnot
 */
@interface FSLink : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/**
 * @brief	Get a quadrilateral by index.
 *
 * @details The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSLink::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/**
 * @brief	Set quadrilaterals.
 *
 * @details	The order of points in a quadrilateral should be :
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *			If any single point of the new quadrilaterals is outside the region defined by rectangle of current link annotation,
 *			new quadrilaterals will not be ignored and not set to current link annotation.
 *
 * @param[in]	quadPoints		A valid array of quadrilaterals. It should not be <b>nil</b>.
 */
-(void)setQuadPoints : (NSArray<FSQuadPoints*>*)quadPoints;
/**
 * @brief	Get highlighting mode.
 *
 * @return	Highlighting mode value. Please refer to {@link FSHighLightingMode::e_highlightingModeNone FSHighLightingMode::e_highlightingModeXXX} values
 *			and it would be one of these values except {@link FSHighLightingMode::e_highlightingModeToggle}.
 *			-1 means no highlighting mode value is found or error.
 */
-(FSHighLightingMode)getHighlightingMode;
/**
 * @brief	Set highlighting mode.
 *
 * @param[in]	mode		New highlighting mode value.
 *							Please refer to {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeNone FSM_HIGHLIGHTINGMODE::e_highlightingModeXXX} values
 *							and it should be one of these values except {@link FSM_HIGHLIGHTINGMODE::e_highlightingModeToggle}.
 */
-(void)setHighlightingMode : (FSHighLightingMode) mode;
/**
 * @brief	Get action.
 *
 * @return	A ::FSAction object that receives the action data.
 *			<b>nil</b> means no action or failure.
 */
-(FSAction*)getAction;
/**
 * @brief	Set action.
 *
 * @param[in]	action		New action to be set. It should be valid.
 *							Currently only support following types as the new action:<br>
 *							{@link FSActionType::e_actionTypeGoto}, {@link FSActionType::e_actionTypeURI}.
 */
-(void)setAction : (FSAction*) action;
/**
 * @brief	Remove action.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAction;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a free text annotation.
 *
 * @details	A free text annotation displays text directly on the page. So free text annotation does not need a related pop-up annotation to show the text.<br>
 *			Free text annotation is a kind of markup annotation, so class ::FSFreeText is derived from class ::FSMarkup, and also offers functions
 *			to access free text annotation's properties and reset appearance stream of a free text annotation. <br>
 *
 * @note	For a newly created free text annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0, alignment = 0 (as left-justified),
 *			{@link FSDefaultAppearance::flags} = {@link FSDefaultAPFlags::e_defaultAPFont}|{@link FSDefaultAPFlags::e_defaultAPTextColor}|{@link FSDefaultAPFlags::e_defaultAPFontSize},
 *			{@link FSDefaultAppearance::font} is created based on {@link FSStandardFontID::e_fontStandardIDHelvetica},
 *			{@link FSDefaultAppearance::fontSize} = 12, {@link FSDefaultAppearance::textColor} = 0xFF0000FF (blue).
 *
 * @see	FSMarkup
 */
@interface FSFreeText: FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color.
 *
 * @details	Fill color is used to fill the background of text box, and also for some callout line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getFillColor;
/**
 * @brief	Set fill color.
 *
 * @details	Fill color is used to fill the background of text box, and also for some callout line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setFillColor: (unsigned int)fillColor;
/**
 * @brief   Get alignment.
 *
 * @details This property has effect on free text annotation's appearance.
 *
 * @return  The alignment property of a free text annotation.
 */
-(FSAlignment)getAlignment;
/**
 * @brief Set alignment.
 *
 * @details This property has effect on free text annotation's appearance. If user wants the new alignment has effect
 *          on annotation's appearance, please call function {@link FSAnnot::ResetAppearanceStream} after setting
 *          new alignment.
 *
 * @param[in] alignment  It should be one of {@link FSAlignment::e_alignmentLeft, FSAlignment::e_alignmentXXX} <br>.
 *                       If other values is used to set,
 *                       {@link FSAlignment::e_alignmentLeft, FSAlignment::e_alignmentLeft} will be used by default.
 */
-(void)setAlignment: (FSAlignment)alignment;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a free text annotation, inner rectangle is where the annotation's text should be displayed.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*)getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a free text annotation, inner rectangle is where the annotation's text should be displayed.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void)setInnerRect: (FSRectF*)innerRect;
/**
 * @brief	Get default appearance data.
 *
 * @details	Default appearance data can be used in formatting text.
 *
 * @return	The default appearance data.
 *			If there is any error, a FSDefaultAppearance object with following values will be returned:
 *			{@link FSDefaultAppearance::flags} = 0, {@link FSDefaultAppearance::font} = nil,
 *			{@link FSDefaultAppearance::fontSize} = 0, {@link FSDefaultAppearance::textColor} = 0.
 */
-(FSDefaultAppearance*)getDefaultAppearance;
/**
 * @brief	Set default appearance data.
 *
 * @details	Default appearance data can be used in formatting text.
 *
 * @param[in]	defaultAP	The new default appearance data to be set.
 *							{@link FSDefaultAppearance::flags} can be used to decide which information is/are to be updated with the new data;
 *							for those no updated data, they will keep to use old data.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setDefaultAppearance: (FSDefaultAppearance*)defaultAP;
/**
 * @brief	Get line ending style of the start point in a callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have line ending style property. <br>
 *			Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*) getCalloutLineEndingStyle;
/**
 * @brief	Set line ending style of the start point in a callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have line ending style property.<br>
 *			Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setCalloutLineEndingStyle: (NSString*)endingStyle;
/**
 * @brief	Get the count of callout line points.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @return	The count of callout line points. It would be 2 or 3.
 *			If there is any error, 0 will be returned.
 */
-(int)getCalloutLinePointCount;
/**
 * @brief	Get a point of callout line points.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @param[in]	index	Index of the point to be get. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSFreeText::getCalloutLinePointCount}.
 *
 * @return	The specified point of a callout line.
 */
-(FSPointF*)getCalloutLinePoint: (int)index;
/**
 * @brief	Set points for callout line.
 *
 * @details	Only when the intent name of a free text annotation is "FreeTextCallout",
 *			this free text annotation can have callout line points property.
 *			For a callout line, it can contain 2 or 3 points:<br>
 *			<ul>
 *			<li> 2 points represent the starting point and ending point of the callout line.</li>
 *			<li> 3 points represent the starting point, knee point, and ending point of the callout line.</li>
 *			</ul>
 *
 * @param[in]	point1	New point that specifies the start point of the callout line. It should be valid.
 * @param[in]	point2	New point that specifies the second point of the callout line.
 *						<ul>
 *						<li>If parameter <i>point3</i> is just the same as current parameter <i>point2</i>,
 *							the callout line only consists of 2 points, and <i>point2</i> represents the ending point.</li>
 *						<li>If parameter <i>point3</i> is different from current parameter <i>point2</i>,
 *							the callout line consists of 3 points, and <i>point2</i> represents the knee point.</li>
 *						</ul>
 * @param[in]	point3	New point that specifies the third point of the callout line. It can be:
 *						<ul>
 *						<li>If this is just the same as parameter <i>point2</i>, the callout line only consists of 2 points.</li>
 *						<li>If this is valid, the callout line consists of 3 points.</li>
 *						</ul>
 */
-(void)setCalloutLinePoints:(FSPointF*)point1 point2:(FSPointF*)point2  point3:(FSPointF*)point3;
/** @brief	Free the object. */
-(void)dealloc;
@end


/**
 * @brief	Class to access a line annotation.
 *
 * @details	A line annotation displays a single straight line on the page.<br>
 *			Line annotation is a kind of markup annotation, so class ::FSLine is derived from class ::FSMarkup, and also offers functions
 *			to access line annotation's properties and reset appearance stream of a line annotation. <br>
 *			For a line annotation, start point and end point are required. So please ensure that a line annotation
 *			has valid start point and end point before resetting its appearance stream.
 *
 * @note	For a newly created line annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required start point and end point property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1,
 *			line starting/ending styles = "None", no caption is enabled.
 *
 *
 * @see	FSMarkup
 */
@interface FSLine : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a line annotation, please ensure this line annotation has valid start point and end point;
 *			otherwise this line annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get line ending style of the start point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*) getLineStartingStyle;
/**
 * @brief	Set line ending style of the start point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineStartingStyle : (NSString*)startingStyle;
/**
 * @brief	Get line ending style of the end point in a line.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the end point.
 */
-(NSString*)getLineEndingStyle;
/**
 * @brief	Set line ending style of the end point.
 *
 * @details	Possible values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	endingStyle		 String of new line ending style for the end point to be set. It should be in UTF-8 encoding.
 *								 If this is <b>nil</b> or an empty string, "None" will be used as default.
 *								 Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineEndingStyle : (NSString*)endingStyle;
/**
 * @brief	Get fill color for ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color of ending styles. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int) getStyleFillColor;
/**
 * @brief	Set fill color of ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	color		New fill color of ending style. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) setStyleFillColor : (unsigned int) color;
/**
 * @brief	Get the start point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @return	The start point.
 *			A ::FSPointF with value (0, 0) may also mean that no start point is found or there is any error.
 */
-(FSPointF*)getStartPoint;
/**
 * @brief	Set the start point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @param[in]	point	New point that specifies the start point.
 */
-(void)setStartPoint : (FSPointF*) point;
/**
 * @brief	Get the end point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @return	The end point.
 *			A ::FSPointF with value (0, 0) may also mean that no start point is found or there is any error.
 */
-(FSPointF*) getEndPoint;
/**
 * @brief	Set the end point.
 *
 * @details	Start point and end point are required for a line annotation.
 *
 * @param[in]	point	New point that specifies the end point.
 */
-(void)setEndPoint : (FSPointF*) point;
/**
 * @brief	Check whether the content of current line annotation should be replicated as a caption in the appearance or not.
 *
 * @return	<b>YES</b> means the content should be replicated as a caption in the appearance of current line annotation.
 *			<b>NO</b> means not to replicate the content as a caption in the appearance of current lint annotation.
 */
-(BOOL)hasCaption;
/**
 * @brief	Set the flag which is used to decide whether the content of current line annotation
 *			should be replicated as a caption in the appearance or not.
 *
 * @param[in]	cap		<b>YES</b> means the content should be replicated as a caption in the appearance of current line annotation,
 *						while <b>NO</b> means not.
 */
-(void)enableCaption : (BOOL)cap;
/**
 * @brief	Get the position type of caption.
 *
 * @details	Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *			There are two position types of caption:
 *			<ul>
 *			<li>"Inline": means the caption will be centered inside the line.</li>
 *			<li>"Top": means the caption will be on top of the line.</li>
 *			</ul>
 *
 * @return	A string that represents the position type of caption.
 *			If no position type can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getCaptionPositionType;
/**
 * @brief	Set the position type of caption.
 *
 * @details	Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *			There are two position types of caption:
 *			<ul>
 *			<li>"Inline": means the caption will be centered inside the line.</li>
 *			<li>"Top": means the caption will be on top of the line.</li>
 *			</ul>
 *
 * @param[in]	captionPos	 String as position type. It should be one of following string values: "Inline" or "Top".
 */
-(void)setCaptionPositionType : (NSString*)captionPos;
/**
 * @brief	Get caption offset values.
 *
 * @details	Caption offset is the offset of caption from its normal position.<br>
 *			Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *
 * @return	A ::FSOffset object that receives horizontal offset and vertical offset for caption.<br>
 *			A ::FSOffset object with value (0, 0) may also mean that no caption offset values can be found or there is any error.
 */
-(FSOffset*) getCaptionOffset;
/**
 * @brief	Set caption offset values.
 *
 * @details	Caption offset is the offset of caption from its normal position.<br>
 *			Position type of caption is only meaningful when current line annotation should have a caption.
 *			Function {@link FSLine::hasCaption} can be used to check if current line annotation should have a caption,
 *			and function {@link FSLine::enableCaption:} can be used to change the status.<br>
 *
 * @param[in]	offset		New offset values .
 */
-(void)setCaptionOffset : (FSOffset*)offset;
/** brief The ratio string should be like: "1/4 in = 1 ft",indicating that 1/4 inches in default user space is equivalent to 1 foot in real-world measurements. */
-(void)setMeasureRatio: (NSString *)ratio;
/** brief Get the measurement ratio string. */
-(NSString *)getMeasureRatio;
/** brief Set the the displaying unit label. The measure type should be set to 0, only distance measurement is supported. */
-(void)setMeasureUnit: (int)measureType unit: (NSString *)unit;
/** brief Get the displaying unit label. The measure type should be set to 0, only distance measurement is supported. */
-(NSString *)getMeasureUnit: (int)measureType;
/** brief The measure type should be set to 0, only distance measurement is supported. */
-(void)setMeasureConversionFactor: (int)measureType factor: (float)factor;
/** brief The measure type should be set to 0, only distance measurement is supported. */
-(float)getMeasureConversionFactor: (int)measureType;
/** @brief	Free the object. */
-(void)dealloc;
@end

/**
 * @brief	Class to represent ink annotation.
 *
 * @details	An ink annotation represents a freehand "scribble" composed of one or more disjoint paths. <br>
 *			Ink annotation is a kind of markup annotation, so class ::FSInk is derived from class ::FSMarkup, and also offers functions
 *			to access ink annotation's properties and reset appearance stream of an ink annotation. <br>
 *			For a ink annotation, ink list property is required. So please ensure that an ink annotation
 *			has valid ink list property before resetting its appearance stream.
 *
 * @note	For a newly created ink annotation, if user calls function {@link FSInk::resetAppearanceStream} directly
 *			after setting required ink list property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSInk : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of an ink annotation, please ensure this ink annotation has valid ink list;
 *			otherwise this ink annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get ink list data.
 *
 * @details	Ink list property is required for an ink annotation.
 *			The ink list contains one or more stroked path. <br>
 *			In Foxit PDF SDK, class ::FSPDFPath is used to represent the ink list data,
 *			but the point types for ::FSPDFPath object have been specially simplified for ink list.
 *			Only {@link FSPathPointType::e_pointTypeMoveTo} and {@link FSPathPointType::e_pointTypeLineTo} types are used for points in the ink list:
 *			<ul>
 *			<li>a point with type {@link FSPathPointType::e_pointTypeMoveTo} means that this point is the start point of a stroked path.
 *				Usually the first in ::FSPDFPath object should be this type.
 *			</li>
 *			<li>a point with type {@link FSPathPointType::e_pointTypeLineTo} means that this point is in a stroked path,
 *				which is started by a point with with type {@link FSPathPointType::e_pointTypeMoveTo},
 *				and when function {@link FSInk::resetAppearanceStream} is called, Foxit PDF SDK will connect this point with other points by curves.</li>
 *			</ul>
 * @note    Operations such as move the ink annotation, or set a new ink path to this annotation will update its internal ink path data, so that the
 *          previous returned FSPDFPath object would become invalid. Caller must call this API to obtain a new FSPDFPath object.
 *
 * @return	The ink list data.<br>
 *			If no ink list data can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSPDFPath*)getInkList;
/**
 * @brief	Set ink list data.
 *
 * @details	Ink list property is required for an ink annotation.
 *			The ink list contains one or more stroked path. <br>
 *			In Foxit PDF SDK, class ::FSPDFPath is used to represent the ink list data,
 *			but the point types for ::FSPDFPath object have been specially simplified for ink list.
 *			Only {@link FSPathPointType::e_pointTypeMoveTo} and {@link FSPathPointType::e_pointTypeLineTo} types are used for points in the ink list:
 *			<ul>
 *			<li>a point with type {@link FSPathPointType::e_pointTypeMoveTo} means that this point is the start point of a stroked path.
 *				Usually the first in ::FSPDFPath object should be this type.
 *			</li>
 *			<li>a point with type {@link FSPathPointType::e_pointTypeLineTo} means that this point is in a stroked path,
 *				which is started by a point with with type {@link FSPathPointType::e_pointTypeMoveTo},
 *				and when function {@link FSInk::resetAppearanceStream} is called, Foxit PDF SDK will connect this point with other points by curves.</li>
 *			</ul>
 *			Specially, if input parameter <i>inkList</i> contains bezier points (for example, added by function {@link FSPDFPath::cubicBezierTo:point2:point3:}), the control points will be ignored
 *			and only the target point will be used in the ink list data.<br>
 *			User is strongly recommended to pass a valid ::FSPDFPath object only with point types {@link FSPathPointType::e_pointTypeMoveTo} and {@link FSPathPointType::e_pointTypeLineTo}.
 *
 *
 * @param[in]	inkList		New ::FSPDFPath object which specifies the new list data.
 */
-(void)setInkList :(FSPDFPath*) inkList;
/** @brief	Free the object. */
-(void)dealloc;
@end


/**
 * @brief	Class to access a stamp annotation.
 *
 * @details	A stamp annotation displays text or graphics intended to look as if they were stamped on the page with a rubber stamp.<br>
 *			A stamp annotation's appearance can be with an icon or a bitmap.
 *			Currently, Foxit PDF SDK does not have any default appearance for predefined standard stamp icons,
 *			so user should set a customized annotation icon provider to Foxit PDF SDK
 *			by function {@link FSLibrary::setAnnotIconProvider:} if the stamp is represented by icon.<br>
 *			Stamp annotation is a kind of markup annotation, so class ::FSStamp is derived from class ::FSMarkup, and also offers functions
 *			to access stamp annotation's properties and reset appearance stream of a stamp annotation.
 *
 * @note	For a newly created stamp annotation, some properties will be set with default values:<br>
 *			opacity = 1.0, icon name = "Draft".<br>
 *			Before calling {@link FSStamp::resetAppearanceStream}, user should ensure to set a bitmap to the stamp by function {@link FSStamp::setBitmap:},
 *			or set a useful customized annotation icon provider to Foxit PDF SDK by function {@link FSLibrary::setAnnotIconProvider:}.
 *
 * @see	FSMarkup
 * @see FSLibrary
 */
@interface FSStamp : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a stamp annotation, please ensure this stamp annotation has been set valid bitmap,
 *			or it has an icon name, with the supported customized annotation icon provider being set to Foxit PDF SDK;
 *			otherwise this stamp annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get icon name.
 *
 * @details	Stamp annotation has predefined standard icon names: <br>
 *			"Approved", "AsIs", "Confidential", "Departmental", "Draft",
 *			"Experimental", "Expired", "Final", "ForComment", "ForPublicRelease",
 *			"NotApproved", "NotForPublicRelease", "Sold", "TopSecret".<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString*)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	Stamp annotation has predefined standard icon names: <br>
 *			"Approved", "AsIs", "Confidential", "Departmental", "Draft",
 *			"Experimental", "Expired", "Final", "ForComment", "ForPublicRelease",
 *			"NotApproved", "NotForPublicRelease", "Sold", "TopSecret".<br>
 *			Once user set a new icon name to current stamp annotation, please ensure the customized icon provider has been set to Foxit PDF SDK
 *			by function {@link FSLibrary::setAnnotIconProvider:} before function {@link FSStamp::resetAppearanceStream} is called.
 *			For a newly created note annotation, if current function is not called, icon name will be "Draft" by default.<br>
 *
 * @param[in]	iconName	New icon name string to be set.
 *							An empty icon name string means icon of current note annotation would be treated as "Draft".<br>
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName :(NSString*)iconName;
/**
 * @brief	Set bitmap to current stamp annotation.
 *
 * @param[in]	bitmap	A bitmap to be set to current stamp.
 */
-(void)setBitmap :(FSBitmap*) bitmap;
/** @brief	Free the object. */
-(void)dealloc;
@end

/**
 * @brief	Class to access a polygon annotation.
 *
 * @details	A polygon annotation displays a closed polygon on the page.
 *			Polygon annotation is a kind of markup annotation, so class ::FSPolygon is derived from class ::FSMarkup, and also offers functions
 *			to access polygon annotation's properties and reset appearance stream of a polygon annotation. <br>
 *			For a polygon annotation, vertexes property is required. So please ensure that a polygon annotation
 *			has valid vertexes property before resetting its appearance stream.
 *
 * @note	For a newly created polygon annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required vertexes property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSPolygon : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a polygon annotation, please ensure this polygon annotation has valid vertexes property;
 *			otherwise this polygon annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color.
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getFillColor;
/**
 * @brief	Set fill color.
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setFillColor : (unsigned int)fillColor;
/**
 * @brief	Get the count of vertexes.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @return	The count of vertexes.
 */
-(int)getVertexCount;
/**
 * @brief	Get the point value of a vertex, specified by index.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @param[in]	index	The index of a vertex.Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPolygon::getVertexCount}.
 *
 * @return	The point value of a specified vertex.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*)getVertex :(int)index;
/**
 * @brief	Set vertexes.
 *
 * @details	Vertexes property is required for a polygon annotation.
 *
 * @param[in]	vertexes		A valid point array for vertexes. It should not be <b>nil</b> and should contains at least 2 points as vertexes.
 */
-(void)setVertexes :(NSArray<FSPointF*>*)vertexes;
/** @brief	Free the object. */
-(void)dealloc;
@end

/**
 * @brief	Class to access a polyline annotation.
 *
 * @details	A polyline annotation (PDF 1.5) is similar to a polygon, except that the first and last vertex are
 *			not implicitly connected. <br>
 *			Polyline annotation is a kind of markup annotation, so class ::FSPolyLine is derived from class ::FSMarkup, and also offers functions
 *			to access polyline annotation's properties and reset appearance stream of a polyline annotation. <br>
 *			For a polyline annotation, vertexes property is required. So please ensure that a polyline annotation
 *			has valid vertexes property before resetting its appearance stream.
 *
 * @note	For a newly created polyline annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			after setting required vertexes property and not setting any other properties,
 *			the default appearance will be used:<br>
 *			border width = 2.0, border style = {@link FSM_BORDERSTYLE::e_borderStyleSolid},
 *			border color = 0xFFFF0000 (red), opacity = 1.0.
 *
 * @see	FSMarkup
 */
@interface FSPolyLine : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a polyline annotation, please ensure this polyline annotation has valid vertexes property;
 *			otherwise this polyline annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get fill color for some line ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @return	The fill color. Format: 0xAARRGGBB.
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no fill color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getStyleFillColor;
/**
 * @brief	Set fill color for some line ending styles.
 *
 * @details	Fill color is used for some line ending styles:<br>
 *			"Square", "Circle", "Diamond", "ClosedArrow", "RClosedArrow".
 *
 * @param[in]	fillColor	New fill color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setStyleFillColor : (unsigned int)fillColor;
/**
 * @brief	Get the count of vertexes.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @return	The count of vertexes.
 */
-(int)getVertexCount;
/**
 * @brief	Get the point value of a vertex, specified by index.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @param[in]	index	The index of a vertex. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPolyLine::getVertexCount}.
 *
 * @return	The point value of a specified vertex.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*)getVertex : (int)index;
/**
 * @brief	Set vertexes.
 *
 * @details	Vertexes property is required for a polyline annotation.
 *
 * @param[in]	vertexes		A valid point array of vertexes. It should not be <b>nil</b> and should contains at least 2 points as vertexes.
 */
-(void)setVertexes : (NSArray<FSPointF*>*)vertexes;
/**
 * @brief	Get line ending style of the start point.
 *
 * @details	Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the start point.
 */
-(NSString*)getLineStartingStyle;
/**
 * @brief	Set line ending style of the start point.
 *
 * @details	Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	startingStyle	String of new line ending style for the start point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineStartingStyle : (NSString*)startingStyle;
/**
 * @brief	Get line ending style of the end point.
 *
 * @details	Valid values for line ending style are:<br>
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @return	The line ending style of the end point.
 */
-(NSString*)getLineEndingStyle;
/**
 * @brief	Set line ending style of the end point.
 *
 * @details	Valid values for line ending style are:
 *			"None", "Square", "Circle", "Diamond", "OpenArrow",
 *			"ClosedArrow", "Butt", "ROpenArrow", "RClosedArrow", "Slash".
 *
 * @param[in]	endingStyle	String of new line ending style for the end point to be set. It should be in UTF-8 encoding if valid.
 *								If this is <b>nil</b> or an empty string, "None" will be used as default.<br>
 *								Please refer to "Details" part of this method about the valid strings for line ending style.
 */
-(void)setLineEndingStyle : (NSString*)endingStyle;
/** @brief	Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a caret annotation.
 *
 * @details	A caret annotation (PDF 1.5) is a visual symbol that indicates the presence of text edits.
 *			Caret annotation is a kind of markup annotation, so class ::FSCaret is derived from class ::FSMarkup, and also offers functions
 *			to access caret annotation's properties and reset appearance stream of a caret annotation. <br>
 *
 * @note	For a newly created caret annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any other properties, the default appearance will be used:<br>
 *			border color = 0xFFA7ABE8 (a kind of purple), opacity = 1.0,
 *
 * @see	FSMarkup
 */
@interface FSCaret :FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr:(void *)cptr swigOwnCObject:(BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Get the inner rectangle.
 *
 * @details	For a caret annotation, inner rectangle means the actual boundaries of underlying caret.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @return	The inner rectangle.
 *			If there is any error, a FSRectF object with {0, 0, 0, 0} will be returned.
 */
-(FSRectF*) getInnerRect;
/**
 * @brief	Set the inner rectangle.
 *
 * @details	For a caret annotation, inner rectangle means the actual boundaries of underlying caret.
 *			The inner rectangle could be just the same as or less than the annotation's rectangle,
 *			and should never be larger than annotation's rectangle.
 *
 * @param[in]	innerRect	New inner rectangle to be set. It should be same as or less than annotation's rectangle.
 */
-(void)setInnerRect : (FSRectF*) innerRect;
/** @brief	Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a file attachment annotation.
 *
 * @details	A file attachment annotation (PDF 1.3) contains a reference to a file, which typically is embedded in the PDF file.
 *			File attachment annotation is a kind of markup annotation, so class ::FSFileAttachment is derived from class ::FSMarkup, and also offers functions
 *			to access file attachment annotation's properties and reset appearance stream of a file attachment annotation. <br>
 *
 * @note	For a newly created file attachment annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFF0000 (red), opacity = 1.0, icon name = "PushPin".
 *
 * @see	FSMarkup
 */
@interface FSFileAttachment : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief	Set a file specification, which should specify an embedded file.
 *
 * @param[in]	fileSpecification	A new file specification object to be set. It should not be <b>nil</b>.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setFileSpec: (FSFileSpec*)fileSpecification;
/**
 * @brief	Get the file specification.
 *
 * @return	The file specification object.
 *			If no file specification property can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSFileSpec*)getFileSpec;
/**
 * @brief	Get icon name.
 *
 * @details	File attachment annotation has predefined standard icon names: <br>
 *			"Graph", "PushPin", "Paperclip", "Tag".<br>
 *			An empty icon name string means current File attachment annotation would be treated as "PushPin".<br>
 *
 * @return	Icon name string, in UTF-8 encoding.
 */
-(NSString *)getIconName;
/**
 * @brief	Set icon name.
 *
 * @details	File attachment annotation has predefined standard icon names: <br>
 *			"Graph", "PushPin", "Paperclip", "Tag".<br>
 *			For a newly created file attachment annotation, if current function is not called, icon name will be "PushPin" by default.
 *
 * @param[in]	iconName	New icon name string to be set.
 *							If it is a valid string, it should be in UTF-8 encoding.<br>
 */
-(void)setIconName: (NSString *)iconName;

-(void)dealloc;

@end


/**
 * @brief	Class to access a pressure sensitive ink annotation.
 *
 * @details	Class {@link ::FSPSInk} represents a Foxit custom annotation type, not a standard annotation type, which is used to store data of pressure sensitive ink to PDF page.
 *			An existed PSInk annotation can be retrieved from PDF page by functions {@link FSPDFPage::getAnnot:} and {@link FSPDFPage::getAnnotAtPos:tolerance:}.
 *			A new PSInk annotation would be returned by function {@link FSPSI::convertToPDFAnnot:rect:rotate:}, instead of {@link FSPDFPage::addAnnot:rect:}.<br>
 *			Class ::FSPSInk is derived from class ::FSAnnot and also offers functions to access annotation's basic properties of a FSPSInk annotation.
 *			Currently, some functions (which are to change annotation's related properties) can be called for a PSInk annotation, but will not have any effect on the appearance of PSInk annotation.
 *			These functions include {@link FSAnnot::setBorderInfo:}, {@link FSAnnot::setBorderColor:}, {@link FSAnnot::removeProperty:}.<br>
 *			Not support to move a PSInk annotation by function {@link FSAnnot::move:} yet.
 *
 * @details Created by {@link FSPSI::convertToPDFAnnot:rect:rotate:}, FSPSInk is not a standard annotation so can't be add to page by {@link FSPDFPage::addAnnot:rect:}.
 */
@interface FSPSInk:  FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/** @brief Free the object. */
-(void)dealloc;

@end

@class FSIconFit;
@class FSImage;

/**
 * A widget annotation (PDF 1.2) is used to represent the appearance of form fields.
 * Class FSWidget is derived from class FSAnnot and also offers functions to get/set widget annotation's properties.<br>
 * Functions {@link FSWidget::GetField} and {@link FSWidget::GetControl} can be used to get the associated form field
 * and form control object. If a widget annotation is not associated with any form field or is associated with
 * a signature field, this widget can still get/set properties, but cannot be reset appearance. For these cases,
 * {@link FSWidget::ResetAppearanceStream} will return <b>false</b> directly.
 *
 * @see FSAnnot
 * @see FSFormField
 * @see FSFormControl
 */
@interface FSWidget : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief Get associated form field.
 *
 * @return A form field object.
 */
-(FSFormField*)getField;
/**
 * @brief Get associated form control.
 *
 * @return A form control object.
 */
-(FSFormControl*)getControl;
/**
 * @brief Reset appearance stream.
 *
 * @details Annotation's appearance is stored as stream in PDF document.
 *          When any appearance related property is changed by corresponding setting functions,
 *          if user wants the effect to be shown in annotation's appearance, current function should be called.<br>
 *          If current widget is associated with a signature field or is not associated with any form field,
 *          current widget cannot be reset appearance stream and current function will return <b>false</b> directly.
 *
 * @return <b>true</b> means success, while <b>false</b> means current widget is not associated
 *         with any form field or is associated with a signature field.
 */
-(BOOL)resetAppearanceStream;
/**
 * @brief Get highlighting mode.
 *
 * @details Highlighting mode is the visual effect to be used when the mouse button is pressed or held down
 *          inside its active area
 *
 * @return Highlighting mode value. Please refer to
 *         {@link FSHighLightingMode::e_highlightingModeNone FSHighLightingMode::e_highlightingModeXXX}
 *         values and it would be one of these values.
 */
-(FSHighLightingMode)getHighlightingMode;
/**
 * @brief Set highlighting mode.
 *
 * @details Highlighting mode is the visual effect to be used when the mouse button is pressed or held down
 *          inside its active area
 *
 * @param[in] mode  New highlighting mode value.
 *                  Please refer to {@link FSHighLightingMode::e_highlightingModeNone FSHighLightingMode::e_highlightingModeXXX}
 *                  values and it should be one of these values.
 *
 * @return None.
 */
-(void)setHighlightingMode: (FSHighLightingMode)mode;
/**
 * @brief Get action.
 *
 * @return A FSAction object that receives the action data. <b>NULL</b> means no action.
 */
-(FSAction*)getAction;
/**
 * @brief Set action.
 *
 * @param[in] action  New action to be set. It should be valid.
 *                    Currently only support following types as the new action:<br>
 *                    {@link FSActionType::e_actionTypeGoto FSActionType::e_actionTypeGoto},
 *                    {@link FSActionType::e_actionTypeURI FSActionType::e_actionTypeURI},
 *                    {@link FSActionType::e_actionTypeJavaScript FSActionType::e_actionTypeJavaScript},
 *                    {@link FSActionType::e_actionTypeNamed FSActionType::e_actionTypeNamed},
 *                    {@link FSActionType::e_actionTypeGoToR FSActionType::e_actionTypeGoToR},
 *                    {@link FSActionType::e_actionTypeGoToE FSActionType::e_actionTypeGoToE},
 *                    {@link FSActionType::e_actionTypeSubmitForm FSActionType::e_actionTypeSubmitForm},
 *                    {@link FSActionType::e_actionTypeResetForm FSActionType::e_actionTypeResetForm},
 *                    {@link FSActionType::e_actionTypeHide FSActionType::e_actionTypeHide},
 *                    {@link FSActionType::e_actionTypeLaunch FSActionType::e_actionTypeLaunch},
 *                    {@link FSActionType::e_actionTypeImportData FSActionType::e_actionTypeImportData}.
 *
 * @return None.
 */
-(void)setAction: (FSAction*)action;
/**
 * @brief Remove action.
 *
 * @return None.
 */
-(void)removeAction;
/**
 * @brief Check if a specified entry exists in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @param[in] mk_entry  An entry in MK dictionary. Please refer to
 *                      {@link FSAnnotMKEntry::e_mkEntryRotation FSAnnotMKEntry::e_mkEntryXXX}
 *                      values and it should be one of these values.
 *
 * @return <b>true</b> means the specified entry exists in the MK dictionary, while <b>false</b> means not.
 */
-(BOOL)hasMKEntry: (FSAnnotMKEntry)mk_entry;
/**
 * @brief Remove a specified entry from the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @param[in] mk_entry  An entry in MK dictionary. Please refer to
 *                      {@link FSAnnotMKEntry::e_mkEntryRotation FSAnnotMKEntry::e_mkEntryXXX}
 *                      values and it should be one of these values.
 *
 * @return None.
 */
-(void)removeMKEntry: (FSAnnotMKEntry)mk_entry;
/**
 * @brief Get the rotation value in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The rotation in MK dictionary specifies the degrees by which the widget annotation is rotated
 *          counterclockwise relative to the page.
 *
 * @return The rotation value in MK dictionary. Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX}
 *         values and it would be one of these values.
 *         Value {@link FSRotation::e_rotationUnknown FSRotation::e_rotationUnknown} means no rotation in MK dictionary.
 */
-(FSRotation)getMKRotation;
/**
 * @brief Set the rotation value in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The rotation in MK dictionary specifies the degrees by which the widget annotation is rotated
 *          counterclockwise relative to the page.
 *
 * @param[in] rotation  The rotation value to be set in MK dictionary. Please refer to
 *                      {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and
 *                      it should be one of these values except value
 *                      {@link FSRotation::e_rotationUnknown FSRotation::e_rotationUnknown}
 */
-(void)setMKRotation: (FSRotation)rotation;
/**
 * @brief Get the border color in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @return The border color in MK dictionary. Value format: 0xRRGGBB. <br>
 *         0 may means no border color in MK dictionary. In this case, please call function
 *         {@link FSWidget::HasMKEntry} with value
 *         {@link FSAnnotMKEntry::e_mkEntryBorderColor FSAnnotMKEntry::e_mkEntryBorderColor} to check.
 */
-(unsigned int)getMKBorderColor;
/**
 * @brief Set the border color in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @param[in] color  The border color to be set in MK dictionary. Value format: 0xRRGGBB.
 *
 * @return None.
 */
-(void)setMKBorderColor: (unsigned int)color;
/**
 * @brief Get the background color in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @return The background color in MK dictionary. Value format: 0xRRGGBB. <br>
 *         0 may means no background color in MK dictionary. In this case, please call function
 *         {@link FSWidget::HasMKEntry} with value
 *         {@link FSAnnotMKEntry::e_mkEntryBackgroundColor FSAnnotMKEntry::e_mkEntryBackgroundColor} to check.
 */
-(unsigned int)getMKBackgroundColor;
/**
 * @brief Set the background color in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *
 * @param[in] color  The background color to be set in MK dictionary. Value format: 0xRRGGBB.
 *
 * @return None.
 */
-(void)setMKBackgroundColor: (unsigned int)color;
/**
 * @brief Get the normal caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Normal caption in MK dictionary is used to displayed when the widget is not
 *          interacting with the user. This is applicable for widget associated with
 *          pushbutton field, check box field or radio button field. For other type of fields, this will be useless.
 *
 * @return Normal caption string, in UTF-8 encoding.
 *         An empty string may means no normal caption in MK dictionary. In this case, please call function
 *         {@link FSWidget::HasMKEntry} with value
 *         {@link FSAnnotMKEntry::e_mkEntryNormalCaption FSAnnotMKEntry::e_mkEntryNormalCaption} to check.
 */
-(NSString*)getMKNormalCaption;
/**
 * @brief Set the normal caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Normal caption in MK dictionary is used to displayed when the widget is not
 *          interacting with the user. This is applicable for widgets associated with
 *          pushbutton field, check box field or radio button field. For other type of fields, this will be useless.
 *
 * @param[in] caption  Normal caption string to be set in MK dictionary, in UTF-8 encoding.
 *                     It can be <b>NULL</b> or an empty string.
 *
 * @return None.
 */
-(void)setMKNormalCaption: (NSString *)caption;
/**
 * @brief Get the rollover caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Rollover caption in MK dictionary is used to displayed when the user rolls the cursor into
 *          its active area without pressing the mouse button.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @return Rollover caption string, in UTF-8 encoding.
 *         An empty string may means no rollover caption in MK dictionary. In this case, please call function
 *         {@link FSWidget::HasMKEntry} with value
 *         {@link FSAnnotMKEntry::e_mkEntryRolloverCaption FSAnnotMKEntry::e_mkEntryRolloverCaption} to check.
 */
-(NSString*)getMKRolloverCaption;
/**
 * @brief Set the rollover caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Rollover caption in MK dictionary is used to displayed when the user rolls the cursor into
 *          its active area without pressing the mouse button.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @param[in] caption  Rollover caption string to be set in MK dictionary, in UTF-8 encoding.
 *                     It can be <b>NULL</b> or an empty string.
 *
 * @return None.
 */
-(void)setMKRolloverCaption: (NSString *)caption;
/**
 * @brief Get the down caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Down caption (or alternate caption) in MK dictionary is used to displayed when the mouse button is
 *          pressed within its active area. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @return Down caption string, in UTF-8 encoding.
 *         An empty string may means no down caption in MK dictionary. In this case, please call function
 *         {@link FSWidget::HasMKEntry} with value
 *         {@link FSAnnotMKEntry::e_mkEntryDownCaption FSAnnotMKEntry::e_mkEntryDownCaption} to check.
 */
-(NSString*)getMKDownCaption;
/**
 * @brief Set the down caption string in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Down caption (or alternate caption) in MK dictionary is used to displayed when the mouse button is
 *          pressed within its active area. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @param[in] caption  Down caption string to be set in MK dictionary, in UTF-8 encoding.
 *                     It can be <b>NULL</b> or an empty string.
 *
 * @return None.
 */
-(void)setMKDownCaption: (NSString *)caption;
/**
 * @brief Get the normal icon bitmap in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Normal icon in MK dictionary is used to displayed when the widget is not
 *          interacting with the user. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @return Normal icon bitmap. NULL means no such bitmap in MK dictionary.
 */
-(FSBitmap*)getMKNormalIconBitmap;
/**
 * @brief Set a bitmap as normal icon in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Normal icon in MK dictionary is used to displayed when the widget is not
 *          interacting with the user. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @param[in] bitmap  A bitmap to be set as normal icon in MK dictionary. It should be valid and
 *                    should not be <b>NULL</b>.
 *
 * @return None.
 */
-(void)setMKNormalIconBitmap: (FSBitmap*)bitmap;
/**
 * @brief Set an image with specified frame index as normal icon in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Normal icon in MK dictionary is used to displayed when the widget is not
 *          interacting with the user. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @param[in] image        An image. One of its frames will be set as normal icon in MK dictionary.
 *                         This image should contain at least one frame and the image type should not be
 *                         {@link FSImageType::e_imageTypeUnknown FSImageType::e_imageTypeUnknown}.
 * @param[in] frame_index  Frame index. Valid range: from 0 to (<i>count</i>-1).
 *                         <i>count</i> is returned by function {@link FSImage::GetFrameCount}.
 */
-(void)setMKNormalIconImage: (FSImage*)image frame_index: (int)frame_index;
/**
 * @brief Get the rollover icon bitmap in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Rollover icon in MK dictionary is used to displayed when the user rolls the cursor into
 *          its active area without pressing the mouse button.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @return Rollover icon bitmap. NULL means no such bitmap in MK dictionary.
 */
-(FSBitmap*)getMKRolloverIconBitmap;
/**
 * @brief Set the rollover icon bitmap in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Rollover icon in MK dictionary is used to displayed when the user rolls the cursor into
 *          its active area without pressing the mouse button.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @param[in] bitmap  A bitmap to be set as rollover icon in MK dictionary. It should be valid and
 *                    should not be <b>NULL</b>.
 *
 * @return None.
 */
-(void)setMKRolloverIconBitmap: (FSBitmap*)bitmap;
/**
 * @brief Set an image with specified frame index as rollover icon in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Rollover icon in MK dictionary is used to displayed when the user rolls the cursor into
 *          its active area without pressing the mouse button.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @param[in] image        An image. One of its frames will be set as rollover icon in MK dictionary.
 *                         This image should contain at least one frame and the image type should not be
 *                         {@link FSImageType::e_imageTypeUnknown FSImageType::e_imageTypeUnknown}.
 * @param[in] frame_index  Frame index. Valid range: from 0 to (<i>count</i>-1).
 *                         <i>count</i> is returned by function {@link FSImage::GetFrameCount}.
 */
-(void)setMKRolloverIconImage: (FSImage*)image frame_index: (int)frame_index;
/**
 * @brief Get the down icon bitmap in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Down icon (or alternate icon) in MK dictionary is used to displayed when the mouse button is
 *          pressed within its active area. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @return Down icon bitmap. NULL means no such bitmap in MK dictionary.
 */
-(FSBitmap*)getMKDownIconBitmap;
/**
 * @brief Set the down icon bitmap in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Down icon (or alternate icon) in MK dictionary is used to displayed when the mouse button is
 *          pressed within its active area. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @param[in] bitmap  A bitmap to be set as down icon in MK dictionary. It should be valid and
 *                    should not be <b>NULL</b>.
 *
 * @return None.
 */
-(void)setMKDownIconBitmap: (FSBitmap*)bitmap;
/**
 * @brief Set an image with specified frame index as down icon in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          Down icon (or alternate icon) in MK dictionary is used to displayed when the mouse button is
 *          pressed within its active area. This is applicable for widget associated with pushbutton field.
 *          For other type of fields, this will be useless.
 *
 * @param[in] image        An image. One of its frames will be set as down icon in MK dictionary.
 *                         This image should contain at least one frame and the image type should not be
 *                         {@link FSImageType::e_imageTypeUnknown FSImageType::e_imageTypeUnknown}.
 * @param[in] frame_index  Frame index. Valid range: from 0 to (<i>count</i>-1).
 *                         <i>count</i> is returned by function {@link FSImage::GetFrameCount}.
 */
-(void)setMKDownIconImage: (FSImage*)image frame_index: (int)frame_index;
/**
 * @brief Get the icon fit information in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The icon fit information specifies how to display the widget annotation's icon within
 *          its annotation rectangle. If present, the icon fit information applies to all of the annotation's icons.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @return A FSIconFit object, which contains the icon fit information in MK dictionary.
 *         If {@link FSIconFit::scale_way_type} is 0, that means no icon fit information in MK dictionary.
 */
-(FSIconFit*)getMKIconFit;
/**
 * @brief Set the icon fit information in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The icon fit information specifies how to display the widget annotation's icon within
 *          its annotation rectangle. If present, the icon fit information applies to all of the annotation's icons.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @param[in] icon_fit  A FSIconFit object which represents the icon fit information to be set in MK dictionary.
 *                      If value of any member in this object is invalid, this function will throw exception
 *                      {@link FSErrorCode::e_errParam FSErrorCode::e_errParam}.
 *                      Please refer to FSIconFit to check the valid value range for each member.
 */
-(void)setMKIconFit: (FSIconFit*)icon_fit;
/**
 * @brief Get the relation of icon and caption in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The relation position of caption and icon specifies where to position the text of
 *          the widget annotation's caption relative to its icon.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @return The relation position of caption and icon. Please refer to
 *         {@link FSAnnotMKIconCaptionRelation::e_mkRelationNoIcon FSAnnotMKIconCaptionRelation::e_mkRelation}
 *         values and it should be one of these values.
 */
-(FSAnnotMKIconCaptionRelation)getMKIconCaptionRelation;
/**
 * @brief Set the relation of icon and caption in the MK dictionary
 *
 * @details MK dictionary is an appearance characteristics dictionary to be used in
 *          constructing a dynamic appearance stream specifying the annotation's visual presentation on the page.
 *          The relation position of caption and icon specifies where to position the text of
 *          the widget annotation's caption relative to its icon.
 *          This is applicable for widget associated with pushbutton field. For other type of fields,
 *          this will be useless.
 *
 * @param[in] relation  The relation position of caption and icon. Please refer to
 *                      {@link FSAnnotMKIconCaptionRelation::e_mkRelationNoIcon FSAnnotMKIconCaptionRelation::e_mkRelationXXX}
 *                      values and it should be one of these values.
 */
-(void)setMKIconCaptionRelation: (FSAnnotMKIconCaptionRelation)relation;

-(void)dealloc;

@end

/**
 * @brief Enumeration for the type of icon scaling way.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSIconScaleWayType) {
    /** @brief Always scale. */
    e_iconScaleWayTypeAlways = 1,
    /** @brief Scale only when icon is bigger than annotation rectangle. */
    e_iconScaleWayTypeBigger = 2,
    /** @brief Scale only when icon is smaller than annotation rectangle. */
    e_iconScaleWayTypeSmaller = 3,
    /** @brief Never scale.*/
    e_iconScaleWayTypeNever = 4
};

/**
 * @brief This class represents icon fit information.
 * Icon fit information is used to specify how to display a button's icon within the annotation rectangle of
 * its associated widget annotation.
 */
@interface FSIconFit : NSObject {
    void *swigCPtr;
    BOOL swigCMemOwn;
}
/** @brief The circumstances under which the icon should be scaled inside
 *         the annotation rectangle. Please refer to
 *         {@link FSIconScaleWayType::e_iconScaleWayTypeAlways FSIconScaleWayType::e_iconScaleWayTypeXXX} values
 *         and it should be one of these values.
 */
@property (nonatomic) FSIconScaleWayType scaleWayType;
/** @brief Indicates whether use proportional scaling or not.
 *         <b>true</b> means to fill the annotation rectangle exactly, without regard to its original
 *         aspect ratio (ratio of width to height).<br><b>false</b> means scale the icon to scale the icon to
 *         fit the width or height of the annotation rectangle while maintaining the icon's original aspect ratio.
 */
@property (nonatomic, getter=isProportionalScaling) BOOL proportionalScaling;
/** @brief The horizontal fraction of left-over space to allocate
 *         at the left and bottom of the icon if the icon is scaled proportionally.
 *         Valid range: 0.0 to 1.0.
 */
@property (nonatomic) float horizontalFraction;
/** @brief The vertical fraction of left-over space to allocate
 *         at the left and bottom of the icon if the icon is scaled proportionally.
 *         Valid range: 0.0 to 1.0.
 */
@property (nonatomic) float verticalFraction;
/** @brief Indicates whether to scale button appearance to fit fully within bounds or not.
 *         <b>true</b> means that the button appearance should be scaled to fit fully within the bounds
 *         of the annotation without taking into consideration the line width of the border.
 */
@property (nonatomic, getter=isFitBounds) BOOL fitBounds;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
-(id)init;
-(id)initWithIconFit: (FSIconFit*)iconFit;
/** @brief Set property values. */
-(void)set: (FSIconScaleWayType)type proportionalScaling: (BOOL)proportionalScaling horizontalFraction: (float)horizontalFraction verticalFraction: (float)verticalFraction fitBounds: (BOOL)fitBounds;

-(void)dealloc;

@end

/**
 * @brief This class represents the screen annotation.
 */
@interface FSScreen : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** @brief Set first frame of image to this screen annotation. */
-(BOOL)setImage: (FSImage*)img;
/** @brief Get the appearance characteristics dictionary. If the dictionary will not set back to this annot, then caller should release it.*/
-(FSPDFDictionary*) getMKDict;
/** @brief Set the appearance characteristics dictionary. Caller should not release the dictionary, annot itself will do.*/
-(void)setMKDict: (FSPDFDictionary*) dict;
/** @brief Set the rotation of the image. */
-(void)setRotation: (FSRotation)rotate;
/** @brief Get the rotation of the image. */
-(FSRotation)getRotation;
/**
 * @brief Reset appearance stream.
 *
 * @details Annotation's appearance is stored as stream in PDF document.
 *          When any appearance related property is changed by corresponding setting functions,
 *          if user wants the effect to be shown in annotation's appearance, current function should be called.
 *
 * @return <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(BOOL)resetAppearanceStream;

-(void)dealloc;

@end

NS_ASSUME_NONNULL_END
