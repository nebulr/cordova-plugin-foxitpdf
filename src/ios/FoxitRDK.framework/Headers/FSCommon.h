/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSCommon.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import <Foundation/Foundation.h>


#ifdef __cplusplus
extern "C" {
#endif
#import <UIKit/UIGestureRecognizer.h>
#import <UIKit/UIKit.h>
#import <CoreGraphics/CoreGraphics.h>
@class FSAnnotIconProviderCallback;
@class FSPDFDoc;
@class FSPDFPage;
@class FSPDFTextSelect;
@class FSBorderInfo;
@class FSPDFDictionary;
@class FSPDFObject;
@class FSPDFStream;
@class FSPDFArray;
@class FSNote;
@class FSBitmap;
@class FSForm;
@class FSFormField;
@class FSFormControl;
@class FSFormFiller;
@class FSDateTime;
@protocol FSFileReadCallback;
@class FSSignature;
@class FSSignatureCallback;
@class FSReflowPage;
@class FSPDFTextObject;
@class FSPDFMarkedContent;
@class FSPDFGraphicsObjects;
@class FSSecurityCallback;
@class FSAnnot;
@protocol FSDocEventCallback;
    
NS_ASSUME_NONNULL_BEGIN
    
/**
 * @name	Macro Definitions for Annotation Icon Name
 */
/**@{*/

/** @brief	Note icon name: Check. */
#define FS_ANNOT_ICONNAME_TEXT_CHECK                "Check"
    /** @brief	Note icon name: Circle. */
#define FS_ANNOT_ICONNAME_TEXT_CIRCLE				"Circle"
    /** @brief	Note icon name: Comment. */
#define FS_ANNOT_ICONNAME_TEXT_COMMENT				"Comment"
    /** @brief	Note icon name: Cross. */
#define FS_ANNOT_ICONNAME_TEXT_CROSS				"Cross"
    /** @brief	Note icon name: Help. */
#define FS_ANNOT_ICONNAME_TEXT_HELP					"Help"
    /** @brief	Note icon name: Insert. */
#define FS_ANNOT_ICONNAME_TEXT_INSERT				"Insert"
    /** @brief	Note icon name: Key. */
#define FS_ANNOT_ICONNAME_TEXT_KEY					"Key"
    /** @brief	Note icon name: New Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_NEWPARAGRAPH			"NewParagraph"
    /** @brief	Note icon name: Note. */
#define FS_ANNOT_ICONNAME_TEXT_NOTE					"Note"
    /** @brief	Note icon name: Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_PARAGRAPH			"Paragraph"
    /** @brief	Note icon name: Right Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTARROW			"RightArrow"
    /** @brief	Note icon name: Right Pointer. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTPOINTER			"RightPointer"
    /** @brief	Note icon name: Star. */
#define FS_ANNOT_ICONNAME_TEXT_STAR					"Star"
    /** @brief	Note icon name: Up Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPARROW				"UpArrow"
    /** @brief	Note icon name: Up-left Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPLEFTARROW			"UpLeftArrow"
    
    /** @brief	File attachment icon type: Graph. */
#define FS_ANNOT_ICONNAME_FILEATTACH_GRAPH			"Graph"
    /** @brief	File attachment icon type: PaperClip. */
#define FS_ANNOT_ICONNAME_FILEATTACH_PAPERCLIP		"Paperclip"
    /** @brief	File attachment icon type: PushPin. */
#define FS_ANNOT_ICONNAME_FILEATTACH_PUSHPIN			"PushPin"
    /** @brief	File attachment icon type: Tag. */
#define FS_ANNOT_ICONNAME_FILEATTACH_TAG				"Tag"
    
#define FS_ANNOT_ICONNAME_SIGNATURE_FOXIEFILAG		"FoxitFlag"
    
/**@}*/

/**
 * @brief	Enumeration for rotation.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSRotation) {
    /** @brief	No rotation. */
    e_rotation0 = 0,
    /** @brief	Rotate 90 degrees in clockwise direction. */
    e_rotation90,
    /** @brief	Rotate 180 degrees in clockwise direction. */
    e_rotation180,
    /** @brief	Rotate 270 degrees in clockwise direction. */
    e_rotation270,
    /** @brief	Unknown rotation. */
    e_rotationUnknown
};

/**
 * @brief	Enumeration for progress state.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSProgressState) {
    /** @brief	Progress state: any error occurs. */
    e_progressError = 0,
    /** @brief	Progress state: progress needs to be continued. */
    e_progressToBeContinued,
    /** @brief	Progress state: progress is finished. */
    e_progressFinished
};

/**
 * @brief	Enumeration for DIB format.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSDIBFormat) {
    /** @brief	Invalid DIB format. */
    e_dibInvalid = 0,
    /** @brief	DIB format: 24bpp format, with bits order "Blue, Green, Red". Blue is in the lowest order. */
    e_dibRgb = 0x018,
    /** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, not used". Blue is in the lowest order. */
    e_dibRgb32 = 0x020,
    /** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, Alpha". Blue is in the lowest order. */
    e_dibArgb = 0x220,
    /** @brief	DIB format: 8bpp alpha mask. */
    e_dib8bppMask = 0x108,
    /** @brief DIB format: 8bpp format, 256 color RGB bitmap. */
    e_dib8bpp = 0x008
};

/**
 * @brief	Enumeration for bitmap interpolation flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSBitmapInterpolationFlag) {
    /** @brief  When set, do not do halftone for shrinking or rotating. */
    e_interpolationDownsample = 1 << 0,
    /** @brief  When set, do interpolation for stretching or transforming. */
    e_interpolationQuadratic  = 1 << 1,
    /** @brief  When set, do bicubic interpolation for stretching or transforming. */
    e_interpolationBicubic    = 1 << 2
};

/**
 * @brief	Enumeration for error code.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSErrorCode) {
    /** @brief	Success, and no error occurs. */
    e_errSuccess = 0,
    /** @brief	File error: file cannot be found or could not be opened. */
    e_errFile,
    /** @brief	Format error: format is invalid. For files, this may also mean that file is corrupted. */
    e_errFormat,
    /**
     * @brief	Password error: invalid password.
     *
     * @details	Usually, this error may occur when loading a PDF document with password.
     *			When meet this, user should call function {@link FSPDFDoc::load:} again, with correct password.
     */
    e_errPassword,
    /** @brief	Handler is invalid. */
    e_errHandler,
    /** @brief	Certificate error: PDF document is encrypted by digital certificate and current user does not have the correct certificate. */
    e_errCertificate,
    /** @brief	Unknown error: any unknown error occurs. */
    e_errUnknown,
    /** @brief	License error: invalid license is used to initialize Foxit PDF SDK library. */
    e_errInvalidLicense,
    /** @brief	Parameter error: value of any input parameter for a function is invalid. */
    e_errParam,
    /** @brief	Unsupported error: some types are not supported.*/
    e_errUnsupported,
    /** @brief	Memory error: out-of-memory error occurs.*/
    e_errOutOfMemory,
    /** @brief	Security handler error: PDF document is encrypted by some unsupported security handler. */
    e_errSecurityHandler,
    /**
     * @brief Not parsed error: content has not been parsed yet.
     *        Usually, this represents PDF page has not been parsed yet.
     */
    e_errNotParsed,
    /** @brief Data cannot be found. */
    e_errNotFound,
    /** @brief Invalid object type. */
    e_errInvalidType,
    /** @brief Data or values conflict. */
    e_errConflict,
    /** @brief Unknown state. */
    e_errUnknownState,
    /**
     * @brief Data is not ready.
     *
     * @note Usually this is used as an exception error code when loading document in asynchronous way.
     */
    e_errDataNotReady,
    /** @brief Data of current object is invalid. */
    e_errInvalidData
};

/**
 * @brief	Enumeration for display mode, which specifies how the document should be displayed when opened.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSDisplayMode) {
    /** @brief	When document is opened, neither document outlines nor thumbnail images are visible. */
    e_displayUseNone = 0,
    /** @brief	When document is opened, document outlines (bookmarks) are visible. */
    e_displayUseOutlines,
    /** @brief	When document is opened, thumbnail images are visible. */
    e_displayUseThumbs,
    /** @brief	When document is opened, full-screen mode, with no menu bar, window controls, or any other windows are visible. */
    e_displayFullScreen,
    /** @brief	When document is opened, optional content group panels are visible. */
    e_displayUseOC,
    /** @brief	When document is opened, attachment panels are visible. */
    e_displayUseAttachment
};

/**
 * @brief	Enumeration for zoom mode.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSZoomMode) {
    /**
     * @brief	Display page with a specific position and a specific zoom factor.
     *
     * @details	If this is used, that means the specific position of the page will be treated as the left-top position when the page is rendered
     *			and this position should be at the upper-left corner of the display area,
     *			and the contents of the page should be magnified by the zoom factor.
     */
    e_zoomXYZ = 1,
    /**
     * @brief	Fit the entire page within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the entire page within the display area both horizontally and vertically.
     *			If the required horizontal and vertical magnification factors are different,
     *			use the smaller of the two, centering the page within the window in the other dimension.
     */
    e_zoomFitPage,
    /**
     * @brief	Fit the entire width of the page within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the entire width of the page within the display area.
     */
    e_zoomFitHorz,
    /**
     * @brief	Fit the entire height of the page within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the entire height of the page within the display area.
     */
    e_zoomFitVert,
    /**
     * @brief	Fit the page content in a specific rectangle entirely within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the page content in the specific rectangle entirely within the display area both horizontally and vertically.
     *			If the required horizontal and vertical magnification factors are different,
     *			use the smaller of the two, centering the rectangle within the display area in the other dimension.
     */
    e_zoomFitRect,
    /**
     * @brief	Fit the bounding box of page entirely within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit its bounding box entirely within the display area both horizontally and vertically.
     *			If the required horizontal and vertical magnification factors are different,
     *			use the smaller of the two, centering the bounding box within the display area in the other dimension.
     */
    e_zoomFitBBox,
    /**
     * @brief	Fit the entire width of the page's bounding box within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the entire width of the page's bounding box within the display area.
     */
    e_zoomFitBHorz,
    /**
     * @brief	Fit the entire height of the page's bounding box within the display area when display the page.
     *
     * @details	If this is used, that means the contents of the page should be magnified
     *			just enough to fit the entire height of the page's bounding box within the display area.
     */
    e_zoomFitBVert
};

/**
 * @brief	Enumeration for module name.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSModuleName) {
    /** @brief	Standard module. */
    e_moduleNameStandard = 0,
    /** @brief	Annotation module. */
    e_moduleNameAnnotation,
};

/**
 * @brief	Enumeration for module right.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSInteger, FSModuleRight) {
    /** @brief	Module right: unknown. */
    e_moduleRightUnknown = -1,
    /** @brief	Module right: no right. */
    e_moduleRightNone = 0,
    /** @brief	Module right: read. */
    e_moduleRightRead,
    /** @brief	Module right: write, including read. */
    e_moduleRightWrite
};

/**
 * @brief	Enumeration for default appearance flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSDefaultAPFlags) {
    /** @brief	Indicates properties {@link FSDefaultAppearance::font} is meaningful. */
    e_defaultAPFont =      1 << 0,
    /** @brief	Indicates properties {@link FSDefaultAppearance::textColor} is meaningful. */
    e_defaultAPTextColor = 1 << 1,
    /** @brief	Indicates property {@link FSDefaultAppearance::fontSize} is meaningful. */
    e_defaultAPFontSize =  1 << 2
};

/**
 * @brief	Enumeration for font styles.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSFontStyles) {
    /** @brief	Font style: fixed pitch. */
    e_fontStyleFixedPitch =  1 << 0,
    /** @brief	Font style: serif. */
    e_fontStyleSerif =       1 << 1,
    /** @brief	Font style: symbolic. */
    e_fontStyleSymbolic =    1 << 2,
    /** @brief	Font style: script. */
    e_fontStyleScript =      1 << 3,
    /** @brief	Font style: non-symbolic. */
    e_fontStyleNonSymbolic = 1 << 5,
    /** @brief	Font style: italic. */
    e_fontStyleItalic =      1 << 6,
    /** @brief	Font style: all cap. */
    e_fontStyleAllCap =      1 << 16,
    /** @brief	Font style: small cap. */
    e_fontStylesSmallCap =   1 << 17,
    /** @brief	Font style: force bold. */
    e_fontStylesBold =       1 << 18
};

/**
 * @brief	Enumeration for font charset.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSFontCharSet) {
    /** @brief	Font charset: ANSI (United States, Western Europe). */
    e_fontCharsetANSI = 0,
    /** @brief	Font charset: System default, for unknown or mapping purpose. */
    e_fontCharsetDefault = 1,
    /** @brief	Font charset: Standard symbols. */
    e_fontCharsetSymbol = 2,
    /** @brief	Font charset: Japanese (Shift-JIS). */
    e_fontCharsetShift_JIS = 128,
    /** @brief	Font charset: Korean (Wansung). */
    e_fontCharsetHangeul = 129,
    /** @brief	Font charset: Simplified Chinese. */
    e_fontCharsetGB2312 = 134,
    /** @brief	Font charset: Traditional Chinese. */
    e_fontCharsetChineseBig5 = 136,
    /** @brief	Font charset: Thai. */
    e_fontCharsetThai = 222,
    /** @brief	Font charset: Eastern European. */
    e_fontCharsetEastEurope = 238,
    /** @brief	Font charset: Russian. */
    e_fontCharsetRussian = 204,
    /** @brief	Font charset: Greek. */
    e_fontCharsetGreek = 161,
    /** @brief	Font charset: Turkish. */
    e_fontCharsetTurkish = 162,
    /** @brief	Font charset: Hebrew. */
    e_fontCharsetHebrew = 177,
    /** @brief	Font charset: Arabic. */
    e_fontCharsetArabic = 178,
    /** @brief	Font charset: Baltic. */
    e_fontCharsetBaltic = 186
};

/**
 * @brief	Enumeration for font charset.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSStandardFontID) {
    /** @brief	Standard font: Courier. */
    e_fontStandardIDCourier = 0,
    /** @brief	Standard font: Courier-Bold. */
    e_fontStandardIDCourierB,
    /** @brief	Standard font: Courier-BoldOblique, Bold italic. */
    e_fontStandardIDCourierBI,
    /** @brief	Standard font: Courier-Oblique, Italic. */
    e_fontStandardIDCourierI,
    /** @brief	Standard font: Helvetica. */
    e_fontStandardIDHelvetica,
    /** @brief	Standard font: Helvetica-Bold. */
    e_fontStandardIDHelveticaB,
    /** @brief	Standard font: Helvetica-BoldOblique, Bold italic. */
    e_fontStandardIDHelveticaBI,
    /** @brief	Standard font: Helvetica-Oblique, Italic. */
    e_fontStandardIDHelveticaI,
    /** @brief	Standard font: Times-Roman. */
    e_fontStandardIDTimes,
    /** @brief	Standard font: Times-Bold. */
    e_fontStandardIDTimesB,
    /** @brief	Standard font: Times-BoldItalic. */
    e_fontStandardIDTimesBI,
    /** @brief	Standard font: Times-Italic. */
    e_fontStandardIDTimesI,
    /** @brief	Standard font: Symbol. */
    e_fontStandardIDSymbol,
    /** @brief	Standard font: ZapfDingbats. */
    e_fontStandardIDZapfDingbats
};

/**
 * @brief	Enumeration for point type in a PDF path.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSPathPointType) {
    /** @brief      Indicates that the point is the first point of a figure. */
    e_pointTypeMoveTo = 1,
    /** @brief      Indicates that a line is drawn from the previous point to this point. */
    e_pointTypeLineTo,
    /** @brief      Indicates that a line is drawn from the previous point to this point,
     *			and this point will also be connected to the nearest {@link FSPathPointType::e_pointTypeMoveTo} point before this point,
     *			in order to close current figure.
     */
    e_pointTypeLineToCloseFigure,
    /** @brief      Indicates that this point is a control point or ending point for a Bezier spline. */
    e_pointTypeBezierTo,
    /** @brief      Indicates that this point is the ending point for a Bezier spline,
     *			and this point will also be connected to the nearest {@link FSPathPointType::e_pointTypeMoveTo} point before this point,
     *			in order to close current figure.
     */
    e_pointTypeBezierToCloseFigure
};

/**
 * @brief   Enumeration for flatten options.
 *
 * @details Values of this enumeration indicate the option of flatten.
 */
typedef NS_OPTIONS(NSUInteger, FSFlattenOptions) {
    /** @brief  Flatten contents for all. */
    e_flattenOptionAll    =  0,
    /** @brief  Flatten a PDF page without annotations.  */
    e_flattenOptionNoAnnot =    1 << 0,
    /** @brief  Flatten a PDF page without form controls.  */
    e_flattenOptionNoFormControl = 1 << 1
};
    
    
/**
 * @brief	Enumeration for user permissions of a PDF document.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSUserPermissions) {
    /**
     * @brief	Print PDF document with normal mode. (Bit 3 in permission value)
     *
     * @details	If user wants to print a higher quality level of PDF document, please set current value with {@link FSUserPermissions::e_permPrintHigh} together.
     */
    e_permPrint = 1 << 2,
    /**
     * @brief	Modify PDF contents. (Bit 4 in permission value)
     *
     * @details	If this value is set, user can modify contents of PDF document
     *			by operations other than those controlled by {@link FSUserPermissions::e_permAnnotForm}, {@link FSUserPermissions::e_permFillForm} and {@link FSUserPermissions::e_permAssemble} values.
     */
    e_permModify	= 1 << 3,
    /**
     * @brief	Extract PDF contents. (Bit 5 in permission value)
     *
     * @details	If this value is set, user can copy or otherwise extract text and graphics from the document
     *			by operations other than that controlled by {@link FSUserPermissions::e_permExtractAccess} value.
     */
    e_permExtract = 1 << 4,
    /**
     * @brief	Operate text annotations and fill in interactive form fields. (Bit 6 in permission value)
     *
     * @details	If {@link FSUserPermissions::e_permModify} is also set, user can create or modify interactive form fields (including signature fields).
     */
    e_permAnnotForm = 1 << 5,
    /**
     * @brief	Fill PDF form. (Bit 9 in permission value)
     *
     * @details	If this value is set, user can fill in interactive form fields (including signature fields),
     * 			even if {@link FSUserPermissions::e_permAnnotForm} is not used.
     */
    e_permFillForm = 1 << 8,
    /**
     * @brief	Disabilities support. (Bit 10 in permission value)
     *
     * @details	If this value is set, user can extract text and graphics in support of accessibility to users with disabilities
     *			or for other purposes.
     */
    e_permExtractAccess = 1 << 9,
    /**
     * @brief	Assemble PDF document. (Bit 11 in permission value)
     *
     * @details	If this value is set, it enables to assemble the document (insert, rotate, or delete pages
     * 			and create bookmarks or thumbnail images), regardless if {@link FSUserPermissions::e_permModify} is set or not.
     */
    e_permAssemble = 1 << 10,
    /**
     * @brief	Print PDF document with higher qualities. (Bit 12 in permission value)
     *
     * @details	If this value is not set (and {@link FSUserPermissions::e_permPrint} is set), printing is limited to a low-level
     * 			representation of the appearance, possibly of degraded quality.
     */
    e_permPrintHigh = 1 << 11
};

/**
 * @brief	Enumeration for page box type.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSPageBoxType) {
    /**
     * @brief	Media Box for page boundary.
     *
     * @details	The boundary of the physical medium on which page is to be displayed or printed.
     */
    e_pageMediaBox = 0,
    /**
     * @brief	Crop Box for page boundary.
     *
     * @details	The region to which the contents of page are to be clipped (cropped) while displaying or printing.
     */
    e_pageCropBox,
    /**
     * @brief	Trim Box for page boundary.
     *
     * @details	The region to which the contents of page should be clipped while outputting in a production environment.
     */
    e_pageTrimBox,
    /**
     * @brief	Art Box for page boundary.
     *
     * @details	The intended dimensions of a finished page after trimming.
     */
    e_pageArtBox,
    /**
     * @brief	Bleed Box for page boundary.
     *
     * @details	The extent of page's meaningful content (including potential white space) as intended by page's creator.
     */
    e_pageBleedBox
};
    
/**
 * @brief	Enumeration for markup annotation's state model.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotStateModel) {
    /**
     * @brief	Markup annotation state model: marked.
     */
    e_annotStateModelMarked = 1,
    /**
     * @brief	Markup annotation state model: review.
     */
    e_annotStateModelReview
};

/**
 * @brief	Enumeration for markup annotation's state.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotState) {
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked})
     *			The annotation has been marked by the user.
     */
    e_annotStateMarked = 1,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelMarked})
     *			The annotation has has not been marked by the user.
     */
    e_annotStateUnmarked,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
     *			The user agrees with the change.
     */
    e_annotStateAccepted,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
     *			The user disagrees with the change.
     */
    e_annotStateRejected,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
     *			The change has been cancelled.
     */
    e_annotStateCancelled,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
     *			The change has been completed.
     */
    e_annotStateCompleted,
    /**
     * @brief	(Used for {@link FSM_ANNOTSTATEMODEL::e_annotStateModelReview})
     *			The user has indicated nothing about the change.
     */
    e_annotStateNone = 7
};
    
/**
 * @brief	Enumeration for some PDF annotation property.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSAnnotProperty) {
    /**
     * @brief	Annotation property: modified date.
     */
    e_annotPropertyModifiedDate = 0,
    /**
     * @brief	Annotation property: creation date.
     *
     * @details	Only markup annotations can have creation date property.
     */
    e_annotPropertyCreationDate,
    /**
     * @brief	Annotation property: border color
     */
    e_annotPropertyBorderColor,
    /**
     * @brief	Annotation property: fill color
     *
     * @details	Only following annotations can have fill color property:<br>
     *			square, circle, free text, line, polygon, polyline.
     */
    e_annotPropertyFillColor
};
    
/**
 * @brief Enumeration for the type of the progress.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSProgressType) {
    /** @brief Parse progress. */
    e_progressParse,
    /** @brief Import pages progress */
    e_progressImportPages,
    /** @brief Render page progress */
    e_progressRenderPage,
    /** @brief Render page quickly progress */
    e_progressQuickRenderPage,
    /** @brief Render re-flow page progress */
    e_progressReflowRenderPage,
    /** @brief Render page progress */
    e_progressRenderBitmap,
    /** @brief Signature sign progress */
    e_progressSignatureSign,
    /** @brief Signature verification progress */ 
    e_progressSignatureVerify,
    /** @brief Save progress */ 
    e_progressSave
};
/**
 * @brief	Class for catching Objective-C Exceptions in a Swift project.
 */
@interface FSSwiftException : NSObject
/**
 * @brief	Execute a block and catch Objective-C Exceptions.
 *
 * @param[in]	 tryBlock   A block that contains methods which may throw Objective-C exceptions.
 * @param[in]	 error    Exceptions to be thrown if there is any error during block.
 *
 * @return	<b>YES</b> means successfully, otherwise return <b>NO</b>.
 */
+(BOOL)tryException: (void(^)(void))tryBlock error:(__autoreleasing NSError **)error;

@end
    
/**
 * @brief	Class to represent a callback object to notify the Foxit PDF SDK events.
 *
 * @details	All the pure virtual functions in this class are used as callback functions and should be implemented by user.
 *			An implemented ::FSNotifier object can be set to Foxit PDF SDK by function {@link FSLibrary::setNotifier:}.
 */
@interface FSNotifier : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to be triggered when Foxit PDF SDK runs out of the memory.
 */
-(void)OnOutOfMemory;
/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Structure for identity properties of current user, which is used for callback function {@link FSActionHandler::getIdentityProperties}.
 */
@interface FSIdentityProperties : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Set value.
 *
 * @param[in]	corporation	The corporation name, in UTF-8 encoding.
 * @param[in]	email		The email address, in UTF-8 encoding.
 * @param[in]	loginName	The login name, in UTF-8 encoding. Usually, this is the name used to log in current operating system.
 * @param[in]	name		The user name, in UTF-8 encoding.
 */
-(void)set: (NSString *)corporation email: (NSString *)email loginName: (NSString *)loginName name: (NSString *)name;
/** @brief      Set the corporation name, in UTF-8 encoding. */
-(void)setCorporation: (NSString *)value;
/** @brief      Get the corporation name. */
-(NSString *)getCorporation;
/** @brief      Set the email address, in UTF-8 encoding. */
-(void)setEmail: (NSString *)value;
/** @brief      Get the email address. */
-(NSString *)getEmail;
/** @brief      Set the login name, in UTF-8 encoding. Usually, this is the name used to log in current operating system. */
-(void)setLoginName: (NSString *)value;
/** @brief      Get the login name. */
-(NSString *)getLoginName;
/** @brief      Set the user name, in UTF-8 encoding. */
-(void)setName: (NSString *)value;
/** @brief      Get the user name. */
-(NSString *)getName;
/** @brief      Init the object. */
-(id)init;
/** @brief      Free the object. */
-(void)dealloc;

@end
    

/**
 * @brief	Structure for identity properties of current user, which is used for callback function {@link FSActionHandler::getIdentityProperties}.
 */
@interface FSProgressive : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/** @brief	Continue a progressive process.
 *
 * @return {@link FSProgressState::e_progressFinished FSProgressState::e_progressFinished}
 *         means the current process is finished successfully.<br>
 *         {@link FSProgressState::e_progressToBeContinued FSProgressState::e_progressToBeContinued}
 *         means the current process is suspended, applications need to call this function again,
 *         {@link FSProgressState::e_progressError FSProgressState::e_progressError} means any error occurs.
 */
-(FSProgressState)resume;

/**
 * @brief Get the rate of progress when start a progressive process,
 *        see the FSProgressType defined in common head file.
 *
 * @return An integer between 0 and 100 (inclusive) indicating the progress.
 *         -1 means parameter error.
 */
-(int)getRateOfProgress;

/** @brief      Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represents a callback object for performing PDF actions.
 *
 * @details	All the pure virtual functions in this class are used as callback functions
 *			and should be implemented by user, to perform PDF actions, such as javascript actions.<br>
 *			For optional callback functions, empty implementation is allowed.
 */
@interface FSActionHandler : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Optional callback function used to receive current page index.
 *
 * @param[in]	pdfDoc		The PDF document object.
 *
 * @return	Current page index.
 *			The value should be stared from 0 and less than page count of the specified document.
 */
-(int)getCurrentPage:(FSPDFDoc*)pdfDoc;

/**
 * @brief	Optional callback function used to set the current page by index.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index which is used to change current page.
 *							The value would be stared from 0 and less than page count of the specified document.
 */
-(void)setCurrentPage:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;

/**
 * @brief	Optional callback function used to receive current displaying rotation of the page on PDF viewer.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index, to specify which page's rotation is to be retrieved.
 *							The value would be stared from 0 and less than page count of the specified document.
 *
 * @return	The rotation of specified page.
 *			Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and it should be one of these values.
 */
-(FSRotation)getPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex;

/**
 * @brief	Optional callback function used to set the rotation value of a page on PDF viewer.
 *
 * @param[in]	pdfDoc		The PDF document object.
 * @param[in]	pageIndex	Page index, to specify which page's rotation is to be changed.
 *							The value would be stared from 0 and less than page count of the specified document.
 * @param[in]	rotation	New rotation value.
 *							Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and it would be one of these values.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPageRotation:(FSPDFDoc*)pdfDoc pageIndex:(int)pageIndex rotation:(FSRotation)rotation;

/**
 * @brief	Optional callback function used to pop up a dialog to show warnings or hints.
 *
 * @param[in]	msg			The message string to be displayed in the dialog. It should be in UTF-8 encoding.
 * @param[in]	title		The title of the dialog. It should be in UTF-8 encoding.
 * @param[in]	type		Type of button group. It can be one of following values:<br>
 *							<ul>
 *							<li>0: OK;(default value.)</li>
 *							<li>1: OK, Cancel;</li>
 *							<li>2: Yes, NO; </li>
 *							<li>3: Yes, NO, Cancel.</li>
 *							</ul>
 * @param[in]	icon		Icon type. It can be one of following values:<br>
 *							<ul>
 *							<li>0: Error;(default value.)</li>
 *							<li>1: Warning;</li>
 *							<li>2: Question;</li>
 *							<li>3: Status.</li>
 *							</ul>
 *
 * @return	The return value should be one of following values:<br>
 *			<ul>
 *			<li>1: OK;</li>
 *			<li>2: Cancel; </li>
 *			<li>3: NO;</li>
 *			<li>4: Yes;</li>
 *			</ul>
 */
-(int)alert: (NSString *)msg title: (NSString *)title type: (int)type icon: (int)icon;

/**
 * @brief	Optional callback function used to get identity properties of current user.
 *
 * @return	A FSIdentityProperties object that receives the identity properties of current user.
 */
-(FSIdentityProperties*)getIdentityProperties;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to access a file specification.
 *
 * @details	A PDF file can refer to the contents of another file by using a file specification.
 *			File specification can simply represents the file path of another file,
 *			or represents the whole content of another file, which is embedded to current PDF file.
 */
@interface FSFileSpec : NSObject
{
    void *swigCPtr;
    BOOL swigCMemOwn;
}
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief	Create a file specification object.
 *
 * @param[in]	pdfDoc	The PDF document object, to which the new file specification object will belongs.
 *
 * @return	A new file specification object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(id)initWithPDFDoc:(FSPDFDoc*)pdfDoc;

/**
 * @brief	Create a file specification object.
 *
 * @param[in]	pdfDoc	The PDF document object, to which the new file specification object will belongs.
 * @param[in]	pdfObject	A valid PDF object. It should be either a dictionary object or a PDF reference object:
 *						<ul>
 *						<li>If it is a PDF dictionary object, it should be a JavaScript action dictionary.</li>
 *						<li>If it is a PDF reference object, it should refer to a JavaScript action dictionary.</li>
 *						</ul>
 *						This PDF object can be retrieved from {@link FSPDFNameTree} in type {@link FSNameTreeType::e_nameTreeJavaScript}.
 *
 * @return	A new file specification object.
 *			If there is any error, this function will return <b>NULL</b>.
 */
-(id)initWithPDFDoc:(FSPDFDoc*)pdfDoc pdfObject:(FSPDFObject*)pdfObject;

/**
 * @brief	Get the file name.
 *
 * @return	The file name, in UTF-8 encoding.
 *			If no file name can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getFileName;
/**
 * @brief	Set the file name.
 *
 * @details	This function is required for a newly created file specification object.
 *
 * @param[in]	fileName	The file name to be set, in UTF-8 encoding. It should not be <b>nil</b>.
 */
-(void)setFileName:(NSString*)fileName;
/**
 * @brief	Get the size of embedded file.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	File size of embedded file.
 */
-(unsigned long long)getFileSize;
/**
 * @brief	Get the file data of embedded file.
 *
 * @return	A file read object and user can call methods of <CODE>FileRead</CODE> to read the file data.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(id<FSFileReadCallback>)getFileData;
/**
 * @brief	Embed the whole content of a file which is specified by input file path.
 *
 * @details	When this function succeeds, the whole content of specified file will be embedded to the PDF document that current file specification belongs to.
 *
 * @param[in]	filePath	A full path of a local file, in UTF-8 encoding.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)embed:(NSString*)filePath;
/**
 * @brief	Check whether current file specification object represents an embedded file or not.
 *
 * @return	<b>YES</b> means current file specification object represent an embedded file. <br>
 *			<b>NO</b> means current file specification object does not represent an embedded file.
 */
-(BOOL)isEmbedded;
/**
 * @brief	Get the descriptive text associated with current file specification.
 *
 * @return	The descriptive text, in UTF-8 encoding.
 *			If no descriptive text can be found or there is any error, this function will return an empty string.
 */
-(NSString*)getDescription;
/**
 * @brief	Set the descriptive text associated with current file specification.
 *
 * @param[in]	description		New descriptive text to be set, in UTF-8 encoding.
 *								It should not be <b>nil</b>.
 */
-(void)setDescription:(NSString*)description;
/**
 * @brief	Get creation date and time about when the embedded file was created.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	The creation date time of embedded file.
 *			If no creation data time is found or there is any error, this function will return a {@link ::FSDateTime} will all value 0.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Set the creation date and time for the embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @param[in]	dateTime	New creation date and time to be set.
 *							It should not be <b>nil</b> and its value should be valid.
 */
-(void)setCreationDateTime:(const FSDateTime*)dateTime;
/**
 * @brief	Get modified date and time about when the embedded file was last modified.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @return	The modified date time of embedded file.
 *			If no creation data time is found or there is any error, this function will return a {@link ::FSDateTime} will all value 0.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set last modified date and time for the embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.
 *
 * @param[in]	dateTime	New last modified date and time to be set.
 *							It should not be <b>nil</b> and its value should be valid.
 */
-(void)setModifiedDateTime:(const FSDateTime*)dateTime;
/**
 * @brief	Get the checksum for embedded file.
 *
 * @details	This function is only useful if current file specification object represents an embedded file.<br>
 *			A 16-byte string that is the checksum of the bytes of the uncompressed embedded file.
 *			The checksum is calculated by applying the standard MD5 message-digest algorithm
 *			to the bytes of the embedded file stream.
 *
 * @return	The checksum string.
 *			If no checksum can be found or there is any error, this function will return an empty string.
 */
-(NSData*)getChecksum;
/**
 * @brief	Set  the checksum for embedded file. (Not affect local file)
 *
 * @details	This function is only useful if current file specification object represents an embedded file.<br>
 *			A 16-byte string that is the checksum of the bytes of the uncompressed embedded file.
 *			The checksum is calculated by applying the standard MD5 message-digest algorithm
 *			to the bytes of the embedded file stream.
 *
 * @param[in]	checksum		New checksum to be set.
 */
-(void)setChecksum:(NSData*)checksum;

/**
 * @brief	Get the PDF dictionary of current file specification.
 *
 * @return	A PDF dictionary object.
 */
-(FSPDFDictionary*)getDict;

/** @brief Free the object. */
-(void)dealloc;

@end
    

    
/**
 * @brief	Class to represent the library management for global configuration.
 *
 * @details	It contains functions to initialize/re-initialize/release Foxit PDF SDK library, and also contains functions for global use.<br>
 *			Any application should load Foxit PDF SDK by function {@link FSLibrary::init:key:} before calling any other Foxit PDF SDK functions.
 */
@interface FSLibrary : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Initialize Foxit PDF SDK Library, with valid license information.
 *
 * @details	This function should be called first before other functions in Foxit PDF SDK can be called.
 *
 * @param[in]	sn		String of sn information, which can be retrieved from "SN=" part in key file "rdk_sn.txt".
 * @param[in]	key		String of key information, which can be retrieved from "Sign=" part in key file "rdk_key.txt".
 *
 * @return	{@link FSErrorCode::e_errSuccess} means success.
 *			{@link FSErrorCode::e_errInvalidLicense} means input license information is invalid.
 *			{@link FSErrorCode::e_errParam} means parameter <i>sn</i> or <i>key</i> is <b>nil</b> or empty string.
 */
+(FSErrorCode)init: (NSString *_Nullable)sn key: (NSString *_Nullable)key;
/**
 * @brief	Reinitialize Foxit PDF SDK Library.
 *
 * @details	When user meets out-of-memory error, user can call this function to reinitialize Foxit PDF SDK Library.
 *
 * @return	{@link FSErrorCode::e_errSuccess} means success.
 *			For more information about error code values, please refer to {@link FSErrorCode::e_errSuccess FSErrorCode::e_errXXX} values.
 */
+(FSErrorCode)reinit;
/**
 * @brief	Release all resource allocated by Foxit PDF SDK Library.
 *
 * @details	User can call this function to release all memory blocks allocated by the library.
 *			After this function is called, user should not call any function of Foxit PDF SDK.
 */
+(void)release;
/**
 * @brief	Get the version of current Foxit PDF SDK library.
 *
 * @return	The library version string.
 */
+(NSString*)getVersion;
/**
 * @brief Set the upper limit of PDF library cache size.
 *
 * @details If no cache size limit is set by application, the cache size will be set to 200 MegaBytes
 *          internally by default.
 *
 * @param[in] size  The upper limit of the cache, in MegaBytes, 0~4096.
 *                  If set to 0, the mean is not use limit of cache size.
 *
 * @return <b>true</b> means success, while <b>false</b> means failure.
 */
+(bool)setCacheSize: (unsigned int)size;

/**
 * @brief Enable or disable javascript for PDF.
 *
 * @details Javascript for PDF is enabled by default.
 *
 * @param[in] enable_javascript  <b>true</b> means to enable javascript, and <b>false</b> means to
 *                               disable javascript. If this function is not called, javascript for
 *                               PDF is enabled by default.
 *
 * @return <b>true</b> means success, while <b>false</b> means failure.
 */
+(bool)enableJavaScript: (bool)enable_javascript;

/**
 * @brief	Get the authority of a specific module.
 *
 * @param[in]	module	Module name. It should be one of {@link FSModuleName::e_moduleNameStandard FSModuleName::e_moduleNameXXX} values.
 *
 * @return	The right of specific module. It would be one of {@link FSModuleRight::e_moduleRightUnknown FSModuleName::e_moduleRightXXX} values.
 */
+(FSModuleRight)getModuleRight: (FSModuleName)module;
/**
 * @brief	Set a customized annotation icon provider to Foxit PDF SDK.
 *
 * @details	User can call this function to set a customized icon provider for annotation.
 *			If this function has been called several times, Foxit PDF SDK will only keep the last icon provider.
 *			Foxit PDF SDK will use a default standard icon provider if there is no provider been set.
 *
 * @param[in]	iconProvider		Pointer to a customized annotation icon provider, which is implemented based on class ::FSAnnotIconProviderCallback.
 *									If this is <b>nil</b>, customized annotation icon provider will be removed from Foxit PDF SDK and default standard icon provider will be used instead.
 *									Application should ensure this icon provider object valid until it has been removed from Foxit PDF SDK or function {@link FSLibrary::release} is called.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @note	Icon provider's ID and version are treated as the name of the icon provider, so please offer different "ID + version" for different icon providers
 *			by callback functions {@link FSAnnotIconProviderCallback::getProviderID} and {@link FSAnnotIconProviderCallback::getProviderVersion}.
 */
+(BOOL)setAnnotIconProvider: (FSAnnotIconProviderCallback*)iconProvider;
/**
 * @brief	Set a notifier to Foxit PDF SDK.
 *
 * @details	User can call this function to set a notifier to Foxit PDF SDK, so that when SDK events (such as OOM) occurs, user would be notified.
 *
 * @param[in]	notifier	A ::FSNotifier object. User should ensure all the callback functions have been implemented in application level.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setNotifier: (FSNotifier*)notifier;

/**
 * @brief	Set an action handler to Foxit PDF SDK, in aid of performing PDF actions.
 *
 * @details	User should implement an action handler and call this function to set the action handler to Foxit PDF SDK if PDF actions need to be performed,
 *			such as filling a PDF form.
 *
 * @param[in]	actionHandler	A customized action handler object.
 *								User should ensure all the callback functions have been implemented in application level.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setActionHandler:(FSActionHandler*)actionHandler;

/**
 * @brief	Register a third-party handler to Foxit PDF SDK for signing and verifying signature,
 *			along with the filter and sub filter name of the handler.
 *
 * @details	This function should be called first before signing or verifying signature process, if user wants to use a third-party signature handler.
 *
 * @param[in]	filter					The filter name of the signature handler, in ASCII encoding. It should be valid and not empty.
 *										Filter name is the name of the signature handler.
 * @param[in]	subFilter				The sub filter name of the signature handler, in ASCII encoding.
 *										Sub filter is to describe the encoding of signature value and key information in the signature dictionary.
 * @param[in]	signatureHandler		A customized signature handler object, which is implemented by user and based on callback class FSSignatureHandler.
 *										User should ensure all the callback functions have been implemented in application level
 *										and should also ensure this signature handler object valid until Foxit PDF SDK is released by function {@link FSLibrary::release}.
 *									  If this is <b>NULL</b>, The third-party handler will be removed from Foxit PDF SDK.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 * @exception	e_errParam		Value of input parameter is invalid.
 */
+(BOOL)registerSignatureHandler: (NSString *)filter subFilter: (NSString *)subFilter signatureHandler: (FSSignatureCallback * _Nullable)signatureHandler;

/**
 * @brief	Register a security handler to Foxit PDF SDK for decryption of the PDF files with special encryption filters.
 *
 * @param[in]	filter				The filter name of the security handler, in UTF-8 encoding. It should be valid and not empty.<br>
 *									When users implement security callback of {@link ::FSCertificateSecurityCallback}, the filter value must be set to "Adobe.PubSec".<br>
 * @param[in]	callback	A security callback, which is implemented by user and based on callback class {@link ::FSSecurityCallback}.
 *									User should not inherit {@link ::FSSecurityCallback} directly, but inherit its derived class, such as {@link ::FSCertificateSecurityCallback}, etc.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
+(BOOL)registerSecurityCallback:(NSString*)filter callback:(FSSecurityCallback*)callback;

/**
 * @brief	Unregister a security handler from Foxit PDF SDK.
 *
 * @param[in]	filter				The filter name of the security handler, in UTF-8 encoding. It should be valid and not empty.<br>
 *									Usually, the filter name is just the one used to register a security callback in function {@link FSLibrary::registerSecurityCallback:callback:}.<br>
 *									When users implement security callback of {@link ::FSCertificateSecurityCallback}, the filter value must be set to "Adobe.PubSec".<br>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
+(BOOL)unregisterSecurityCallback:(NSString*)filter;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/** @brief	Class represents a recovery manager to recover SDK when out-of-memory error occurs. It will help to clear the memory, free the cache and reload the document. */
@interface FSRecoveryManager : NSObject
/**
 * @brief	Receive a shared instance of recovery manager.
 *
 * @return	The recovery manager instance.
 */
+(FSRecoveryManager*)sharedInstance;
/**
 * @brief	Reload the specified PDF document.
 *
 * @details	When there is an OOM, user may call this function to reload the document.
 *			The editing content will not be saved because there is no more memory left.
 *
 * @param[in]	pdfDoc	The PDF document to be reloaded. It will be invalid when the document reloaded.
 *
 * @return	The new document object.
 */
-(FSPDFDoc* _Nullable) reloadDoc:(FSPDFDoc*)pdfDoc;
@end
    
    
/************************************************************************************************
 *									Basic data structures or classes							*
 *************************************************************************************************/

/**
 * @brief	Class to represent a point, in floating point.
 */
@interface FSPointF : NSObject

{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief	X coordinate value, in floating point.*/
@property (nonatomic,assign) float x;
/** @brief	Y coordinate value, in floating point.*/
@property (nonatomic,assign) float y;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current point.
 *
 * @param[in]	x	Horizontal coordinate value for the point, in floating point.
 * @param[in]	y	Vertical coordinate value for the point, in floating point.
 */
-(void)set: (float)x y: (float)y;
/**
 * @brief	Set horizontal coordinate value of the point, in floating point.
 *
 * @param[in]	value	Value for horizontal coordinate, in floating point.
 */
-(void)setX: (float)value;
/**
 * @brief	Get horizontal coordinate value of the point, in floating point.
 *
 * @return	Horizontal coordinate value, in floating point.
 */
-(float)getX;
/**
 * @brief	Set vertical coordinate value of the point, in floating point.
 *
 * @param[in]	value	Value for vertical coordinate, in floating point.
 */
-(void)setY: (float)value;
/**
 * @brief	Get vertical coordinate value of the point, in floating point.
 *
 * @return	Vertical coordinate value, in floating point.
 */
-(float)getY;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**  @brief	class for offset, in float. */
typedef  FSPointF FSOffset;

/**
 * @brief	Class to represent a rectangle, in floating point.
 */
@interface FSRectF : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in float. */
@property (nonatomic,assign) float left;
/** @brief	Bottom coordinate value, in float. */
@property (nonatomic,assign) float bottom;
/** @brief	Right coordinate value, in float */
@property (nonatomic,assign) float right;
/** @brief	Top coordinate value, in float. */
@property (nonatomic,assign) float top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in floating point.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in floating point.
 * @param[in]	right		Right coordinate value for the rectangle, in floating point.
 * @param[in]	top			Top coordinate value for the rectangle, in floating point.
 */
-(void)set: (float)left bottom: (float)bottom right: (float)right top: (float)top;
/**
 * @brief	Set left coordinate value , in floating point.
 *
 * @param[in]	value	Value for left coordinate, in floating point.
 */
-(void)setLeft: (float)value;
/**
 * @brief	Get left coordinate value, in floating point.
 *
 * @return	Left coordinate value, in floating point.
 */
-(float)getLeft;
/**
 * @brief	Set bottom coordinate value , in floating point.
 *
 * @param[in]	value	Value for bottom coordinate, in floating point.
 */
-(void)setBottom: (float)value;
/**
 * @brief	Get bottom coordinate value, in floating point.
 *
 * @return	Bottom coordinate value, in floating point.
 */
-(float)getBottom;
/**
 * @brief	Set right coordinate value , in floating point.
 *
 * @param[in]	value	Value for right coordinate, in floating point.
 */
-(void)setRight: (float)value;
/**
 * @brief	Get right coordinate value, in floating point.
 *
 * @return	Right coordinate value, in floating point.
 */
-(float)getRight;
/**
 * @brief	Set top coordinate value , in floating point.
 *
 * @param[in]	value	Value for top coordinate, in floating point.
 */
-(void)setTop: (float)value;
/**
 * @brief	Get top coordinate value, in floating point.
 *
 * @return	Top coordinate value, in floating point.
 */
-(float)getTop;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represent a rectangle, in integer.
 */
@interface FSRectI : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in integer. */
@property (nonatomic,assign) int left;
/** @brief	Bottom coordinate value, in integer. */
@property (nonatomic,assign) int bottom;
/** @brief	Right coordinate value, in integer. */
@property (nonatomic,assign) int right;
/** @brief	Top coordinate value, in integer. */
@property (nonatomic,assign) int top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in integer.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in integer.
 * @param[in]	right		Right coordinate value for the rectangle, in integer.
 * @param[in]	top			Top coordinate value for the rectangle, in integer.
 */
-(void)set: (int)left top: (int)top right: (int)right bottom: (int)bottom;
/**
 * @brief	Set left coordinate value, in integer.
 *
 * @param[in]	value	Value for left coordinate, in integer.
 */
-(void)setLeft: (int)value;
/**
 * @brief	Get left coordinate value, in integer.
 *
 * @return	Left coordinate value, in integer.
 */
-(int)getLeft;
/**
 * @brief	Set top coordinate value, in integer.
 *
 * @param[in]	value	Value for top coordinate, in integer.
 */
-(void)setTop: (int)value;
/**
 * @brief	Get top coordinate value, in integer.
 *
 * @return	Top coordinate value, in integer.
 */
-(int)getTop;
/**
 * @brief	Set right coordinate value, in integer.
 *
 * @param[in]	value	Value for right coordinate, in integer.
 */
-(void)setRight: (int)value;
/**
 * @brief	Get right coordinate value, in integer.
 *
 * @return	Right coordinate value, in integer.
 */
-(int)getRight;
/**
 * @brief	Set bottom coordinate value, in integer.
 *
 * @param[in]	value	Value for bottom coordinate, in integer.
 */
-(void)setBottom: (int)value;
/**
 * @brief	Get bottom coordinate value, in integer.
 *
 * @return	Bottom coordinate value, in integer.
 */
-(int)getBottom;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represent a matrix, used for transformation between two coordinate systems.
 *
 * @details	The transformation between two coordinate systems is represented by a 3-by-3
 *			transformation matrix written as follows:
 *			<pre>
 *			|a  b  0|
 *			|c  d  0|
 *			|e  f  1|
 *			</pre>
 *			Because a transformation matrix has only six elements that can be changed, it is
 *			usually specified in PDF as the six-element array [a b c d e f].
 */
@interface FSMatrix : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief	Coefficient a. */
@property (nonatomic,assign) float a;
/** @brief	Coefficient b. */
@property (nonatomic,assign) float b;
/** @brief	Coefficient c. */
@property (nonatomic,assign) float c;
/** @brief	Coefficient d. */
@property (nonatomic,assign) float d;
/** @brief	Coefficient e. */
@property (nonatomic,assign) float e;
/** @brief	Coefficient f. */
@property (nonatomic,assign) float f;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set the value for current matrix.
 *
 * @param[in]	a		Value for coefficient a.
 * @param[in]	b		Value for coefficient b.
 * @param[in]	c		Value for coefficient c.
 * @param[in]	d		Value for coefficient d.
 * @param[in]	e		Value for coefficient e.
 * @param[in]	f		Value for coefficient f.
 */
-(void)set: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f;
/**
 * @brief	Get the reverse matrix.
 *
 * @return	The reverse matrix.
 */
-(FSMatrix*)getReverse;
/**
 * @brief	Transform a float point.
 *
 * @param[in]	point	A float point to be transformed.
 *
 * @return	The transformed point.
 */
-(FSPointF*)transform: (FSPointF*)point;
/**
 * @brief	Transform a float rectangle.
 *
 * @param[in]	rect	A float rectangle to be transformed.
 *
 * @return	The transformed rectangle.
 */
-(FSRectF*)transformRect: (FSRectF*)rect;
/**
 * @brief	Set coefficient a.
 *
 * @param[in]	value	Value for coefficient a.
 */
-(void)setA: (float)value;
/**
 * @brief	Get coefficient a.
 *
 * @return	Coefficient a value.
 */
-(float)getA;
/**
 * @brief	Set coefficient b.
 *
 * @param[in]	value	Value for coefficient b.
 */
-(void)setB: (float)value;
/**
 * @brief	Get coefficient b.
 *
 * @return	Coefficient b value.
 */
-(float)getB;
/**
 * @brief	Set coefficient c.
 *
 * @param[in]	value	Value for coefficient c.
 */
-(void)setC: (float)value;
/**
 * @brief	Get coefficient c.
 *
 * @return	Coefficient c value.
 */
-(float)getC;
/**
 * @brief	Set coefficient d.
 *
 * @param[in]	value	Value for coefficient d.
 */
-(void)setD: (float)value;
/**
 * @brief	Get coefficient d
 *
 * @return	Coefficient d value.
 */
-(float)getD;
/**
 * @brief	Set coefficient e.
 *
 * @param[in]	value	Value for coefficient e.
 */
-(void)setE: (float)value;
/**
 * @brief	Get coefficient e
 *
 * @return	Coefficient e value.
 */
-(float)getE;
/**
 * @brief	Set coefficient f.
 *
 * @param[in]	value	Value for coefficient f.
 */
-(void)setF: (float)value;
/**
 * @brief	Get coefficient f
 *
 * @return	Coefficient f value.
 */
-(float)getF;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
    
/** @brief	Class to represent date, time and timezone. */
@interface FSDateTime : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief	Year. It should be a four-digit number, such as 2014. */
@property (nonatomic,assign) unsigned short year;
/** @brief	Month. Valid range: from 1 to 12. */
@property (nonatomic,assign) unsigned short month;
/** @brief	Day of month. Valid range: from 1 to 31. */
@property (nonatomic,assign) unsigned short day;
/** @brief	Hour. Valid range: from 0 to 23. */
@property (nonatomic,assign) unsigned short hour;
/** @brief	Minute. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short minute;
/** @brief	Second. Valid range: from 0 to 60. 60 for leap second. */
@property (nonatomic,assign) unsigned short second;
/** @brief	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable. */
@property (nonatomic,assign) unsigned short millisecond;
/**
 * @brief	Hour of time zone. Valid range: from -12 to 12.
 *
 * @details	Positive value for the eastern time zone, and negative value for the western time zone.
 */
@property (nonatomic,assign) short UTHourOffset;
/** @brief	Minute of time zone. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short UTMinuteOffset;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	year			Year. It should be a four-digit number, such as 2014.
 * @param[in]	month			Month. Valid range: from 1 to 12.
 * @param[in]	day				Day of month. Valid range: from 1 to 31.
 * @param[in]	hour			Hour. Valid range: from 0 to 23.
 * @param[in]	minute			Minute. Valid range: from 0 to 59.
 * @param[in]	second			Second. Valid range: from 0 to 60. 60 for leap second.
 * @param[in]	millisecond	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable.
 * @param[in]	UTHourOffset	Hour of time zone. Valid range: from -12 to 12.
 *								Positive value for the eastern time zone, and negative value for the western time zone.
 * @param[in]	UTMinuteOffset	Minute of time zone. Valid range: from 0 to 59.
 */
-(void)set: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second millisecond: (unsigned short)millisecond UTHourOffset: (short)UTHourOffset UTMinuteOffset: (unsigned short)UTMinuteOffset;
/**
 * @brief	Set value for year.
 *
 * @param[in]	value	Value for year. It should be a four-digit number, such as 2014.
 */
-(void)setYear: (unsigned short)value;
/**
 * @brief	Get value for year.
 *
 * @return	Value for year. It would be a four-digit number, such as 2014.
 */
-(unsigned short)getYear;
/**
 * @brief	Set value for month.
 *
 * @param[in]	value	Value for month. Valid range: from 1 to 12.
 */
-(void)setMonth: (unsigned short)value;
/**
 * @brief	Get value for month.
 *
 * @return	Value for month. Valid range: from 1 to 12.
 */
-(unsigned short)getMonth;
/**
 * @brief	Set value for day of month.
 *
 * @param[in]	value	Value for day of month. Valid range: from 1 to 31.
 */
-(void)setDay: (unsigned short)value;
/**
 * @brief	Get value for day of month.
 *
 * @return	Value for day of month. Valid range: from 1 to 31.
 */
-(unsigned short)getDay;
/**
 * @brief	Set value for hour.
 *
 * @param[in]	value	Value for hour. Valid range: from 0 to 23.
 */
-(void)setHour: (unsigned short)value;
/**
 * @brief	Get value for hour.
 *
 * @return	Value for hour. Valid range: from 0 to 23.
 */
-(unsigned short)getHour;
/**
 * @brief	Set value for minute.
 *
 * @param[in]	value	Value for minute. Valid range: from 0 to 59.
 */
-(void)setMinute: (unsigned short)value;
/**
 * @brief	Get value for minute.
 *
 * @return	Value for minute. Valid range: from 0 to 59.
 */
-(unsigned short)getMinute;
/**
 * @brief	Set value for second.
 *
 * @param[in]	value	Value for second. Valid range: from 0 to 60. 60 for leap second.
 */
-(void)setSecond: (unsigned short)value;
/**
 * @brief	Get value for second.
 *
 * @return	Value for second. Valid range: from 0 to 60. 60 for leap second.
 */
-(unsigned short)getSecond;
/**
 * @brief	Set value for millisecond.
 *
 * @param[in]	value	Value for millisecond. Valid range: from 0 to 999.
 *
 * @note	Currently, PDF standard does not support millisecond, so user can omit this field if this is not applicable.
 */
-(void)setMillisecond: (unsigned short)value;
/**
 * @brief	Get value for millisecond.
 *
 * @return	Value for millisecond. Valid range: from 0 to 999.
 *			Currently, this function would always return 0 because PDF standard does not support it.
 */
-(unsigned short)getMillisecond;
/**
 * @brief	Set the offset from Universal Coordinated Time (UTC) by hours.
 *
 * @param[in]	value	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *						Positive value for the eastern time zone, and negative value for the western time zone.
 */
-(void)setUTHourOffset: (short)value;
/**
 * @brief	Get the offset from Universal Coordinated Time (UTC) by hours.
 *
 * @return	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *			Positive value for the eastern time zone, and negative value for the western time zone.
 */
-(short)getUTHourOffset;
/**
 * @brief	Set the offset from Universal Coordinated Time (UTC) by minutes.
 *
 * @param[in]	value	Minutes offset from UTC minute. Valid range: from 0 to 59.
 */
-(void)setUTMinuteOffset: (unsigned short)value;
/**
 * @brief	Get the offset from Universal Coordinated Time (UTC) by minutes.
 *
 * @return	Minutes offset from UTC minute. Valid range: 0 to 59.
 */
-(unsigned short)getUTMinuteOffset;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to access a font.
 */
@interface FSFont : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new font with given attribute.
 *
 * @param[in]	fontName		The typeface name of the font to be created. It should be in UTF-8 encoding.
 * @param[in]	fontStyles		Font styles.
 *								Please refer to {@link FSFontStyles::e_fontStyleFixedPitch FSFontStyles::e_fontStyleXXX} values
 *								and it can be one or a combination of these values.
 * @param[in]	weight			Original font weight. 0 means unspecified.
 * @param[in]	charset			The charset of the font to be created.
 *								Please refer to {@link FSFontCharSet::e_fontCharsetANSI FSFontCharSet::e_fontCharsetXXX} values
 *								and this should be one of these values.
 *
 * @return A new font object.
 */
-(id)initWithFontName: (NSString*) fontName fontStyles: (FSFontStyles)fontStyles weight: (int)weight  charset: (FSFontCharSet) charset;
/**
 * @brief	Create a new standard font by a standard font ID.
 *
 * @param[in]	fontID		Standard font ID of the font to be created.
 *							Please refer to {@link FSStandardFontID::e_fontStandardIDCourier FSStandardFontID::e_fontStandardIDXXX} values
 *
 * @return A new font object.If there is any error, this function will return <b>nil</b>.
 */
-(id)initWithStandardFontID :(FSStandardFontID) fontID;

/**
 * @brief Construct a font from a font file.
 *
 * @param[in] font_file_path  A full path to an existing font file (including file name and extension),
 *                            in UTF-8 string.
 * @param[in] face_index      The zero-based face index. Valid range: from 0 to (<i>count</i>-1).
 *                            Please call the system functions to get the <i>faceCount</i>.
 * @param[in] charset         The charset of the font to be created. Please refer to
 *                            {@link foxit::e_fontCharsetANSI FSFontCharSet::e_fontCharsetXXX} values
 *                            and this should be one of these values.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(id)initWithFontFile :(NSString*) font_file_path face_index:(int)face_index charset:(FSFontCharSet)charset;

/**
 * @brief	Retrieve the face name.
 *
 * @return	The face name. It would be in UTF-8 encoding.
 */
-(NSString*)getName;

/**
 * @brief Judge whether the current font is bold or not.
 *
 * @return <b>true</b> means bold, while <b>false</b> means not.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(bool)isBold;

/**
 * @brief Judge whether the current font object is italic or not.
 *
 * @return <b>true</b> means italic, while <b>false</b> means not.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(bool)isItalic;

/**
 * @brief Judge whether current font is embedded in a specified PDF document or not.
 *
 * @param[in] document  A PDF document object. It should not be <b>NULL</b>.
 *
 * @return <b>true</b> means the font is embedded in the PDF document, while <b>false</b> means not.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(bool)isEmbedded:(FSPDFDoc*) document;

/**
 * @brief Get an ascent value of the current font.
 *
 * @return The ascent value.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(int)getAscent;

/**
 * @brief Get a descent value of the current font.
 *
 * @return The descent value.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(int)getDescent;

/**
 * @brief Get a specific character bounding box of a font.
 *
 * @param[in] unicode  A character unicode value.
 *
 * @return The character bounding box.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(FSRectI*)getCharBBox: (unsigned int)unicode;

/**
 * @brief Get a specific character width of a font.
 *
 * @param[in] unicode  A character unicode value.
 *
 * @return Character width.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(float)getCharWidth: (unsigned int)unicode;

/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class for default appearance data, which is used for free text annotation.
 */
@interface FSDefaultAppearance :NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/**
 * @brief	Flags to indicate which properties of {@link ::FSDefaultAppearance} are meaningful.
 *
 * @details	Please refer to {@link FSDefaultAPFlags::e_defaultAPFont FSDefaultAPFlags::e_defaultAPXXX} values
 *			and this can be one or a combination of these values. 0 means no property of {@link ::FSDefaultAppearance} is meaningful.
 */
@property (nonatomic,assign) FSDefaultAPFlags flags;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FSDefaultAPFlags::e_defaultAPFont})
 *			Font for default appearance. It should be a valid ::FSFont object when it is useful.
 */
@property (nonatomic,retain) FSFont* font;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FSDefaultAPFlags::e_defaultAPFontSize})
 *			Font size for default appearance. It should be above 0 when it is useful.
 */
@property (nonatomic,assign) float fontSize;
/**
 * @brief	(Useful only when {@link FSDefaultAppearance::flags} includes {@link FSDefaultAPFlags::e_defaultAPTextColor})
 *			Text color for default appearance. Format: 0xAARRGGBB. Alpha value is ignored and will always be treated as 0xFF internally.
 */
@property (nonatomic,assign) unsigned int textColor;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** @brief Free the object. */

/**
 * @brief	Set value.
 *
 * @param[in]	flags		Flags to indicate which properties of {@link ::FSDefaultAppearance} are meaningful.
 *							Please refer to {@link FSDefaultAPFlags::e_defaultAPFont FSDefaultAPFlags::e_defaultAPXXX} values
 *							and this can be one or a combination of these values.
 * @param[in]	font		Font for default appearance. Please ensure this is a valid {@link ::FSFont} object when parameter <i>flags</i> includes {@link
 *                                  FSDefaultAPFlags::e_defaultAPFont}.
 * @param[in]	fontSize	Font size for default appearance. Please ensure this is above 0 when parameter <i>flags</i> includes {@link FSDefaultAPFlags::e_defaultAPFontSize}.
 * @param[in]	textColor	Text color for default appearance. Format: 0xAARRGGBB. Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void) set: (FSDefaultAPFlags) flags font: (FSFont*) font fontSize: (float)fontSize textColor: (unsigned int) textColor;
/** @brief Initialize the object. */
-(id)init;
/** @brief Free the object. */
-(void)dealloc;

@end
    
    
/**
 * @brief	Class to represent a PDF path.
 *
 * @details	A PDF path can contain more than one figure.
 */
@interface FSPDFPath : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a new PDF path object.
 *
 * @return	A new empty PDF path object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(id)init;
/**
 * @brief	Get the count of points.
 *
 * @return	The count of points.
 */
-(int)getPointCount;
/**
 * @brief	Get a point specified by index.
 *
 * @param[in]	index	The index of the point. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	The specified point.
 *			Point (0, 0) may means any error occurs in this function.
 */
-(FSPointF*) getPoint : (int)index;
/**
 * @brief	Get the type of a point specified by index.
 *
 * @param[in]	index	The index of the point. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	The type of specified point.
 *			Please refer to {@link FSPathPointType::e_pointTypeMoveTo FSPathPointType::e_pointTypeXXX} values and it would be one of them.
 *			If an error occurs, this function will return 0.
 */
-(FSPathPointType)getPointType : (int) index;
/**
 * @brief	Change the value and type of a point specified by index.
 *
 * @param[in]	index			The index of the point. Valid range: 0 to (<i>count</i>-1).<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 * @param[in]	point			The point to set, in PDF coordinate system.
 * @param[in]	pointType		The type used to set to the point.
 *								Please refer to {@link FSPathPointType::e_pointTypeMoveTo FSPathPointType::e_pointTypeXXX} values
 *								and it should be one of them.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setPoint: (int)index  point: (FSPointF*)point pointType: (FSPathPointType)pointType;
/**
 * @brief	Add a point to the end of current PDF path, to start a new figure.
 *
 * @details	If this function succeeds, the new point will become the new "current point",
 *			and the new figure will become the new "current figure".
 *
 * @param[in]	point	New point, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)moveTo : (FSPointF*) point;
/**
 * @brief	Add a point to the end of current figure, and a line is to be drawn from current point to the new point.
 *
 * @details	If this function succeeds, the new point will become the new "current point".
 *
 * @param[in]	point	New point, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)lineTo : (FSPointF*) point;
/**
 * @brief	Add a cubic bezier spline to the end of current figure, by three points: two control points and one target point.
 *
 * @details	If this function succeeds, parameter <i>point3</i> will become the new "current point".
 *
 * @param[in]	point1		New point as the first control point for cubic bezier, in PDF coordinate system.
 * @param[in]	point2		New point as the second control point for cubic bezier, in PDF coordinate system.
 * @param[in]	point3		New point as target point for cubic bezier, in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)cubicBezierTo: (FSPointF*)point1  point2: (FSPointF*)point2  point3: (FSPointF*)point3;
/**
 * @brief	Close current figure (which is also the last figure in current PDF path).
 *
 * @details	When closing current figure, the last point's type may be changed:
 *			<ul>
 *			<li>If the last point's type is {@link FSPathPointType::e_pointTypeMoveTo}, that means the last figure just has one point and cannot be closed
 *				and current function will return <b>NO</b>.</li>
 *			<li>If the last point's type is {@link FSPathPointType::e_pointTypeLineTo}, the type will be changed to {@link FSPathPointType::e_pointTypeLineToCloseFigure}.</li>
 *			<li>If the last point's type is {@link FSPathPointType::e_pointTypeLineTo}, the type will be changed to {@link FSPathPointType::e_pointTypeBezierToCloseFigure}.</li>
 *			<li>If the last point's type is already {@link FSPathPointType::e_pointTypeLineToCloseFigure} or {@link FSPathPointType::e_pointTypeBezierToCloseFigure},
 *				that means the last figure has been closed. The type will not be changed and function will still return <b>YES</b>.</li>
 *			</ul>
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)closeFigure;
/**
 * @brief	Remove a point specified by index.
 *
 * @param[in]	index	The index of the point to be removed. Valid range: 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPath::getPointCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removePoint : (int)index;
/**
 * @brief	Clear all points.
 */
-(void) clear;
/** @brief Free the object. */
-(void)dealloc;

@end
    
/**
 * @brief	Class to represent a callback object to do file reading.
 * 
 * @details	All the functions in this class are used as callback functions 
 *			and should be implemented by user, to do file reading in a customized way.
 */
@protocol FSFileReadCallback
@required
/**
 * @brief	Required callback function used to get the total size of the file.
 *
 * @return	The file size, in bytes.
 *			If any error occurs, implementation of this function should return 0.
 */
-(unsigned long long)getSize;
/**
 * @brief	Required callback function used to read a data block from the file.
 *
 * @param[in]	offset			Byte offset from the beginning of the file.
 * @param[in]	size			The number of bytes for the block.
 *
 * @return	A data block from the file.
 *			If any error occurs, implementation of this function should return <b>nil</b>.
 */
-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size;
/**
 * @brief Enumeration for type of FSFileReadCallback.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, Type) {
    /** @brief This means current callback object conforms to {@link FSFileReadCallback} protocol. */
    e_TypeNormal = 0,
    e_TypeAsync = 1
};
/**
 * @brief Get the type of file reading callback.
 *
 * @note User should not override this function, otherwise there will be unexpected behavior.
 *
 * @return The type of current file reading callback. It would always be {@link FSFileReadCallback::e_TypeNormal}.
 */
-(Type)getType;
@end
    
/**
 * @brief Class to represents a callback object to do file reading asynchronously.
 *
 * @details This class is derived from class FSFileReadCallback. All the pure virtual functions in this class
 *          and its base class are used as callback functions and should be implemented by user,
 *          in order to asynchronously read file data (especially used for loading document), in a customized way.
 *
 * @see FSFileReadCallback
 */
@protocol FSAsyncFileReadCallback <FSFileReadCallback>
/**
* @brief A callback function used to check whether the specified data section is available or not.
*
* @details A data section is available only if all bytes in the section are available.
*
* @param[in] offset  The offset in file.
* @param[in] size    The size of the data section, which is to be checked if available.
*
* @return <b>TRUE</b> means the specified data section is available,
*         while <b>FALSE</b> means the specified data section is not available yet.
*/
-(BOOL)isDataAvail: (long long)offset size: (long long)size;
/**
* @brief A callback function used to add offset and size to specify a data section,
*        which should be downloaded by application then.
*
* @details Foxit PDF SDK would call this callback function
*          to report downloading hints for the download manager of application.<br>
*          The position (as offset) and size of the section may not be accurate
*          because part of the section might already be available.
*          The download manager must manage this to maximize download efficiency.
*
* @param[in] offset  The offset of a data section, which is to be hinted.
* @param[in] size    The size of the data section.
*
* @return <b>TRUE</b> means success, while <b>FALSE</b> means failure.
*/
-(BOOL)addDownloadHint: (long long)offset size: (long long)size;

@end
    
/**
 * @brief	Class to represent a callback object to do pause control in progressive process.
 * 
 * @details	All the functions in this class are used as callback functions and should be implemented by user.<br>
 * 			Usually, this is used for a process that may take a long time, such as rendering process, PDF page parsing process, 
 *			PDF searching process, and so on.
 */
@interface FSPauseCallback : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** @brief Default initialization. */
-(id)init;
/**
 * @brief	A callback function used to decide whether current process needs to pause or not.
 *
 * @details	During a process, which may takes long time, Foxit PDF SDK will call this function several times to check whether application wants to pause the process or not.
 *			Usually, caller can use a timer to determine how long at most should wait before pause.
 *
 * @return	<b>YES</b> means the process needs to be paused, while <b>NO</b> means the process can continue to run without being paused.
 */
-(BOOL)needPauseNow;

/** @brief Free the object. */
-(void)dealloc;

@end
    
NS_ASSUME_NONNULL_END
    
#ifdef __cplusplus
}
#endif

