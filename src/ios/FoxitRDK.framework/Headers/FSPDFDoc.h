/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFDoc.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"
#import "FSPDFSecurity.h"
#import "FSPDFAnnot.h"
#import "FSPDFGraphicsObject.h"

@class FSReadingBookmark;
@class FSBookmark;

NS_ASSUME_NONNULL_BEGIN
/************************************************************************************************
 *									PDF Document					  							*
 *************************************************************************************************/
/**
 * @brief	Enumeration for page label style.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSPageLabelStyle) {
    /** @brief	Page label style: no numbering style. */
    e_pageLabelStyleNone = 0,
    /** @brief	Page label style: decimal Arabic numerals. */
    e_pageLabelStyleDecimalNums,
    /** @brief	Page label style: uppercase roman numerals. */
    e_pageLabelStyleUpperRomanNums,
    /** @brief	Page label style: lowercase roman numerals. */
    e_pageLabelStyleLowerRomanNums,
    /** @brief	Page label style: uppercase letters (A to Z for the first 26 pages, AA to ZZ for the next 26, and so on). */
    e_pageLabelStyleUpperLetters,
    /** @brief	Page label style: lowercase letters (a to z for the first 26 pages, aa to zz for the next 26, and so on). */
    e_pageLabelStyleLowerLetters
};


/**
 * @brief	Enumeration for password type.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSPasswordType) {
    /** @brief	The password is invalid. */
    e_pwdInvalid = 0,
    /** @brief	No password is used in PDF document. */
    e_pwdNoPassword	,
    /** @brief	A user password is used in PDF document. */
    e_pwdUser,
    /** @brief	An owner password is used in PDF document. */
    e_pwdOwner
};

/**
 * @brief	Enumeration for PDF document saving flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSSaveFlags) {
    /** @brief	Save document normally, without using any special flag. This can only be used alone.*/
    e_saveFlagNormal = 0,
    /**
     * @brief	Save document incrementally.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FSSaveFlags::e_saveFlagNormal}.
     *			Especially, if this is combined with {@link FSSaveFlags::e_saveFlagNoOriginal}, only the increment data will be saved.
     */
    e_saveFlagIncremental = 1 << 0,
    /**
     * @brief	Save document without original data or unchanged objects.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FSSaveFlags::e_saveFlagNormal}.
     *			Especially, if this is combined with {@link FSSaveFlags::e_saveFlagIncremental}, only the increment data will be saved.
     */
    e_saveFlagNoOriginal  = 1 << 1,
    /**
     * @brief	Save document by using XRef stream.
     *
     * @details	This can be used alone or be combined with other saving flags except {@link FSSaveFlags::e_saveFlagNormal}.
     */
    e_saveFlagXRefStream  = 1 << 3,
    /**
     * @brief Save document as a linearized file.
     *
     * @details This should be used alone and cannot be used with other saving flags.
     *          This can only be used for function {@link FSPDFDoc::saveAs}.
     */
    e_saveFlagLinearized = 1 << 12
};

/**
 * @brief	Enumeration for flags for importing pages.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSImportFlags) {
    /** @brief	Import pages normally.*/
    e_importFlagNormal = 0,
    /** @brief	Import pages with layers.*/
    e_importFlagWithLayers = 1 << 0,
    /**
     * @brief	Import pages without cloning stream objects into memory.
     *
     * @details	This flags is only useful when the source PDF document has not been encrypted.
     *			If this flag is used for importing pages, it will reduce memory overhead.
     */
    e_importFlagShareStream = 1 << 1
};

/**
 * A PDF document object can be constructed with an existing one from file path, memory buffer,
 * a custom implemented FSFileReadCallback object and an input file stream, and then call function
 * {@link FSPDFDoc::Load} or {@link FSPDFDoc::startLoad} to load document content. A FSPDFDoc can also be constructed
 * as a new FDF or XFDF document.
 * This class offers functions to retrieve different part of a PDF document. For example:
 * <ul>
 * <li>To retrieve pages, please use functions {@link FSPDFDoc::getPageCount} and {@link FSPDFDoc::getPage}.</li>
 * <li>To retrieve bookmark, such as function {@link FSPDFDoc::getFirstBookmark}, {@link FSPDFDoc::createFirstBookmark},
 *     etc.</li>
 * <li>To retrieve some document's dictionaries (in low-level),
 *     such as functions {@link FSPDFDoc::getCatalog}, {@link FSPDFDoc::getTrailer}, etc.</li>
 * <li>To retrieve reading bookmark, such as functions {@link FSPDFDoc::getReadingBookmarkCount},
 *     {@link FSPDFDoc::getReadingBookmark}, etc.</li>
 * <li>To retrieve interactive form, such as functions {@link FSPDFDoc::hasForm}, {@link FSPDFDoc::getForm},
 *     {@link FSPDFDoc::createForm}.</li>
 * </ul>
 * This class also offers functions for features, such as saving current document as another PDF file,
 * importing pages from another PDF file, setting security handler in order to save encrypted PDF file, and so on.
 *
 * @see FSPDFPage
 * @see FSBookmark
 * @see FSPDFDictionary
 * @see FSReadingBookmark
 * @see FSForm
 */
@interface FSPDFDoc : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create an empty new document.
 *
 * @return	A new ::FSPDFDoc object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-( FSPDFDoc *)init;

/**
 * @brief	Create a PDF document object with an existing PDF document from file path.
 *
 * @param[in]	path	Path name of the PDF file.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDoc*)initWithFilePath: (NSString *)path;
/**
 * @brief	Create a PDF document object with a memory buffer.
 *
 * @param[in]	buffer		A memory buffer, containing the serialized document.
 *							The PDF document data should be fully loaded in the memory buffer.<br>
 *							The memory buffer ownership is not transferred to the PDF document object,
 *							so when the document is not used any more, user should clean-up allocated memory if necessary.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDoc*)initWithMemory: (NSData *)buffer;
/**
 * @brief	Create a document object with a file read instance.
 *
 * @param[in]	fileRead	A file read instance which is implemented by user to load a PDF document.
 *
 * @return	A new PDF document instance.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDoc*)initWithHandler: (id<FSFileReadCallback>)fileRead;
/**
 * @brief	Load current document content by using the specified password.
 *
 * @param[in]	password		The password string, used to load current document content. It can be either user password or owner password.
 *								If current document is not encrypted by password, just pass an empty string.
 *
 * @return	{@link FSErrorCode::e_errSuccess} means success. <br>
 *			{@link FSErrorCode::e_errFile} means there is any error occurs when accessing to current document content.<br>
 *			{@link FSErrorCode::e_errFormat} means the format of current document content is not PDF or the file is corrupted.<br>
 *			{@link FSErrorCode::e_errSecurityHandler} means current PDF document is encrypted by some unsupported security handler.<br>
 *			{@link FSErrorCode::e_errCertificate} means current PDF document is encrypted by digital certificate and current user does not have the correct certificate. <br>
 *			For other error code value, please refer to {@link FSErrorCode::e_errSuccess FSErrorCode::e_errXXX} for more details.
 */
-(FSErrorCode)load: (NSString * _Nullable)password;

/**
 * @brief Progressive loading current document content by using a specified password. This is progressive, which means that the job may not finished when it return.
 *
 * @param[in] password         The password string, used to load current document content.
 *                             It can be either user password or owner password.
 *                             If current document is not encrypted by password, just pass an empty string.
 * @param[in] length           The length of password string.
 * @param[in] is_cache_stream  Whether loading stream content into memory.
 *                             Loading stream content into memory will improve performance for frequent access,
 *                             however, it will also consume a lot of memory space.
 *                             Therefore, we provide an option to leave stream content on file system, and read them
 *                             whenever we need them. If may reduce the performance a little bit, but greatly reduce
 *                             the memory consumption, especially when the file is big.
 * @param[in] pause            Pause object which decides if the importing process needs to be paused.
 *                             This can be <b>NULL</b> which means not to pause during the parsing process.
 *                             If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @details If the function {@link FSProgressive::GetRateOfProgress} return value is between 0 and 100,
 *         means the load process is not finished yet,
 *         and function {@link FSProgressive::Continue}
 *         should be called to continue the process.
 *         FSProgressive object should be deleted by user when progressive progress is finish<br>
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive * _Nullable)startLoad: (NSString *)password length: (int)length is_cache_stream: (BOOL)is_cache_stream pause: (FSPauseCallback* _Nullable)pause;

/** @brief	Get file size of this PDF document.*/
-(unsigned long long)getFileSize;

/**
 * @brief	Check whether current PDF document is a XFA document.
 *
 * @details	Currently, Foxit PDF SDK does not fully support XFA document. When loading a XFA document, Foxit PDF SDK may only load the XFA wrapper level, and cannot access to the real XFA content.
 *			Foxit PDF SDK does not support to insert/import/remove/move pages in a XFA document yet.
 *
 * @return	<b>YES</b> means current document is a XFA document, while <b>NO</b> means current document is not a XFA document.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)isXFA;

/**
 * @brief	Check whether current document is an encrypted file or not.
 *
 * @return	<b>YES</b> means current document is an encrypted file, while <b>NO</b> means current document is not an encrypted file.
 */
-(BOOL)isEncrypted;
/**
 * @brief	Check whether current document has been modified or not.
 *
 * @details	Once function {@link FSPDFDoc::saveAs:saveFlags:} is called successfully, the modified status of current document will be <b>NO</b> until the document is be modified again.
 *
 * @return	<b>YES</b> means current document has been modified, while <b>NO</b> means current document has not been modified.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)isModified;
/**
 * @brief	Get the encryption type.
 *
 * @return	Encryption type.
 *			Please refer to {@link FSEncryptType::e_encryptNone FSEncryptType::e_encryptXXX} values and it would be one of these values.
 */
-(FSEncryptType)getEncryptionType;
/**
 * @brief	For the password protected document, get the type of password, which is used when loading document content in function {@link FSPDFDoc::load:}.
 *
 * @return	Password type.
 *			Please refer to {@link FSPasswordType::e_pwdInvalid FSPasswordType::e_pwdXXX} values and it would be one of these values.
 */
-(FSPasswordType)getPasswordType;
/**
 * @brief	For the password protected document, check the type of a specified password.
 *
 * @details	This function can be used to check the type of any password string.
 *
 * @param[in]	password		The password string to be checked.
 *
 * @return	Password type.
 *			Please refer to {@link FSPasswordType::e_pwdInvalid FSPasswordType::e_pwdXXX} values and it would be one of these values.
 */
-(FSPasswordType)checkPassword: (NSString * _Nullable)password;
/**
 * @brief	Save current PDF document as another PDF file.
 *
 * @param[in]	filePath		File path for the new saved PDF file.
 * @param[in]	saveFlags		Document saving flags.
 *								Please refer to {@link FSSaveFlags::e_saveFlagNormal FSSaveFlags::e_saveFlagXXX} values and this can be one or combination of these values.
 *
 * @return	<b>YES</b> means the saving is successfully finished, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)saveAs: (NSString *)filePath saveFlags:(FSSaveFlags)saveFlags;

/**
 * @brief Start to save current PDF document as another PDF file. This is progressive, which means that the job may not finished when it return.
 *
 * @details If current document is loaded from an existing PDF file
 *          and a different file version has been set by function {@link FSPDFDoc::setFileVersion} before saving,
 *          Foxit PDF SDK will ignore {@link FSSaveFlags::e_saveFlagIncremental FSSaveFlags::e_saveFlagIncremental}
 *          in parameter <i>save_flags</i> and use the file version in saved PDF file.
 *
 * @param[in] file_path   A full path for the new saved PDF file, including file name and extension.
 *                        It should be in UTF-8 encoding.
 * @param[in] save_flags  Document saving flags.
 *                        Please refer to {@link FSSaveFlags::e_saveFlagNormal FSSaveFlags::e_saveFlagXXX}
 *                        values and this can be one or combination of these values.
 * @param[in] pause          Pause object which decides if the saving process needs to be paused.
 *                           This can be <b>NULL</b> which means not to pause during the saving process.
 *                           If this is not <b>NULL</b>, it should be a valid pause object implemented by user.
 *
 * @details If the function {@link FSProgressive::GetRateOfProgress} return value is between 0 and 100,
 *         means the save process is not finished yet,
 *         and function {@link FSProgressive::Continue}
 *         should be called to continue the process.
 *         FSProgressive object should be deleted by user when progressive progress is finish<br>
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive * _Nullable)startSaveAs: (NSString *)file_path save_flags: (FSSaveFlags)save_flags pause: (FSPauseCallback * _Nullable)pause;

/**
 * @brief	Create new bookmark root node.
 *
 * @details	If current PDF document already has the bookmark root node, this function will remove the old bookmark tree
 *			and create a new root node instead.
 *
 * @return	A ::FSBookmark object that represents the root bookmark.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBookmark*) createFirstBookmark;
/**
 * @brief	Remove a specified bookmark.
 *
 * @param[in]	bookmark	The bookmark that would be deleted.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeBookmark:(FSBookmark*) bookmark;
/**
 * @brief	Get the first bookmark.
 *
 * @return	The first bookmark.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBookmark*)getFirstBookmark;
/**
 * @brief	Get the count of pages.
 *
 * @return	The count of page.
 */
-(int)getPageCount;
/**
 * @brief	Get a PDF page by index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	A PDF page instance.
 *			If the page instance is not used any more, please call function {@link FSPDFDoc::closePage:} to close it.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFPage*)getPage: (int)pageIndex;
/**
 * @brief	Close a PDF page by page index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)closePage: (int)pageIndex;
/**
 * @brief	Get the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @return	Display mode value.
 *			Please refer to {@link FSDisplayMode::e_displayUseNone FSDisplayMode::e_displayUseXXX} values and this would be one of its values.
 */
-(FSDisplayMode)getDisplayMode;
/**
 * @brief	Set the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @param[in]	displayMode	Display mode value.
 *							Please refer to {@link FSDisplayMode::e_displayUseNone FSDisplayMode::e_displayUseXXX} values and this should be one of these values.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setDisplayMode: (FSDisplayMode)displayMode;
/**
 * @brief	Get the catalog dictionary.
 *
 * @return	The catalog dictionary.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDictionary*)getCatalog;
/**
 * @brief	Get the trailer dictionary.
 *
 * @return	The trailer dictionary.
 */
-(FSPDFDictionary*)getTrailer;
/**
 * @brief	Get the information dictionary.
 *
 * @details	Document's information dictionary contains metadata for the document.
 *
 * @return	The information dictionary.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFDictionary*)getInfo;
/**
 * @brief	Get the encrypt dictionary.
 *
 * @return	The encrypt dictionary.
 */
-(FSPDFDictionary*)getEncryptDict;
/**
 * @brief	Get an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @return	A ::FSPDFObject object that receives the indirect PDF object.
 *			<b>nil</b> means not found or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFObject*)getIndirectObject: (unsigned int)objnum;
/**
 * @brief	Add a PDF object to current PDF document, to be an indirect object.
 *
 * @details	<ul>
 *			<li>If input PDF object is a direct object (whose indirect object number is 0),
 *				this functions will change it to be an indirect object and add to PDF document.
 *				Then return the new indirect object number.</li>
 *			<li>If input PDF object is already an indirect object (whose indirect object number is above 0),
 *				this function will not add it into document again.
 *				The return value will be its own indirect object number.</li>
 *			</ul>
 *
 * @param[in]	obj		A PDF object instance.
 *
 * @return	The new indirect object number.
 *			If there is any error, 0 will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(unsigned int)addIndirectObject: (FSPDFObject*)obj;
/**
 * @brief	Delete an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)deleteIndirectObject: (unsigned int)objnum;
/**
 * @brief	Get user access permissions.
 *
 * @return	User access permission.
 *			Please refer to {@link FSUserPermissions::e_permPrint FSUserPermissions::e_permXXX} values and this would be one or combination of its values.
 */
-(FSUserPermissions)getUserPermissions;

/**
 * @brief	Check whether current PDF document has interactive form (also known as AcroForm).
 *
 * @return	<b>YES</b> means current document has interactive form.
 *			<b>NO</b> means current document does not have interactive form.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)hasForm;

/**
 * @brief	Get the interactive form object.
 *
 * @return	A ::FSForm object that represents the interactive form.
 *			If current document does not have interactive form or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSForm*)getForm;

/**
 * @brief	Get the count of reading bookmarks.
 *
 * @return	The count of reading bookmarks.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getReadingBookmarkCount;

/**
 * @brief	Get a reading bookmark by index.
 *
 * @param[in]	index	The index of reading bookmarks. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFDoc::getReadingBookmarkCount}.
 *
 * @return	The reading bookmark object with speicified index.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSReadingBookmark*)getReadingBookmark:(int)index;

/**
 * @brief	Insert a reading bookmark to current PDF document.
 *
 * @param[in]	readingBookmarkIndex	The reading bookmark index.<br>
 *										If <i>readingBookmarkIndex</i> is less than 0, the new reading bookmark will be inserted to the first.
 *										If <i>readingBookmarkIndex</i> is equal or larger than the count of reading bookmarks,
 *										the new reading bookmark will be inserted to the end.
 * @param[in]	title					Title string for new reading bookmark. It should be UTF-8 encoding.
 * @param[in]	destPageIndex			The destination page index.
 *
 * @return	A new reading bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSReadingBookmark*)insertReadingBookmark: (int)readingBookmarkIndex title:(NSString*)title pageIndex:(int)destPageIndex;

/**
 * @brief	Remove a reading bookmark from current PDF document.
 *
 * @param[in]	readingBookmark	The reading bookmark to be removed.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeReadingBookmark:(FSReadingBookmark*)readingBookmark;

/**
 * @brief	Get the count of signature.
 *
 * @return	The count of signature.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getSignatureCount;

/**
 * @brief	Get a signature by index.
 *
 * @param[in]	index	The index of signature. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function FSPDFDoc::getSignatureCount.
 *
 * @return	The signature object.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSSignature*)getSignature: (int)index;

/**
 * @brief	Insert a new blank PDF page to document, by index.
 *
 * @details	The new PDF page will have a default size: width is 612 and height is 792.
 *			User can call function {@link FSPDFPage::setSize:height:} to change the size of new PDF page.
 *
 * @param[in]	index	The page index for new page.<br>
 *						If parameter <i>index</i> is less than 0, the new page will be inserted to the first. <br>
 *						If parameter <i>index</i> is equal to or larger than current page count,
 *						the new page will be inserted to the end.
 *
 * @return	A new PDF page object, which represents a blank page.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFPage*)insertPage: (int)index;

/**
 * @brief	Remove specified PDF page.
 *
 * @details	Once the specified PDF page is removed successfully, the page object cannot be used any more.
 *
 * @param[in]	page	A ::FSPDFPage object that represents the PDF page to be removed. It should be in current PDF document.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removePage: (FSPDFPage*)page;

/**
 * @brief	Move specified page to a new index position.
 *
 * @details	If the specified page is successfully moved to the new index position, page index of all the pages between the new index and old index of the specified page will be changed as well.
 *
 * @param[in]	page		A ::FSPDFPage object that represents the PDF page to be moved. It should be in current PDF document.
 * @param[in]	dstIndex	Index of the destination position in page array. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.<br>
 *							If parameter <i>dstIndex</i> is just the same as the page index of parameter <i>page</i>,
 *							no change will be done and this function will return <b>YES</b> directly.
 *
 * @return	<b>YES</b> means success or no need to move current page, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)movePageTo: (FSPDFPage*)page dstIndex: (int)dstIndex;

/**
 * @brief Start to import pages from another PDF document (via file path).This is progressive, which means that the job may not finished when it return.
 *
 * @details Signed signatures in the pages of source PDF document will not be imported into current PDF document.<br>
 *          Currently, if either current PDF document or the source PDF document contains XFA,
 *          not support to do the importing.
 *
 * @param[in] dest_index     A page index in current PDF document.
 *                           This is used to specify where the imported pages will be inserted.
 *                           If parameter <i>dest_index</i> is less than 0,
 *                           the imported pages will be inserted to the first. <br>
 *                           If parameter <i>dest_index</i> is equal to or larger than current page count,
 *                           the imported pages will be inserted to the end.
 * @param[in] flags          Options for importing pages.
 *                           Please refer to macro definitions
 *                           {@link FSImportFlags::e_importFlagNormal FSImportFlags::e_importFlagXXX}
 *                           and this can be one or a combination of these macros.
 * @param[in] layer_name     The name of non-selectable label or the prefix name of the non-selectable label
 *                           to be shown in layer panel of application, in UTF-8 encoding.
 *                           If parameter <i>flags</i> contains
 *                           {@link FSImportFlags::e_importFlagWithLayers FSImportFlags::e_importFlagWithLayers},
 *                           this should not be empty and should be a valid string.
 *                           If parameter <i>flags</i> does not contain
 *                           {@link FSImportFlags::e_importFlagWithLayers FSImportFlags::e_importFlagWithLayers},
 *                           this string will be ignored.
 *                           <ul>
 *                           <li>If all the pages of source PDF document is to be imported to current document,
 *                               all layers from source document will be grouped under a non-selectable label,
 *                               and this string will be directly used as the label. </li>
 *                           <li>If only part of pages of source PDF document is to be imported to current document,
 *                               layers in the same page will be grouped under a single non-selectable label,
 *                               and this string will be used as the prefix name of the label.
 *                               The label will be like "layerName_Page_X". </li>
 *                           </ul>
 * @param[in] src_file_path  A full path of an existing PDF file as the source PDF document
 *                           (including file name and extension), in UTF-8 encoding. It should be a PDF file.
 *                           Some pages will be imported from this PDF file to current PDF document.
 * @param[in] password       The password string for source PDF document.
 *                           If source PDF document is not encrypted by password, just pass an empty string.
 * @param[in] length         The length of password string.
 * @param[in] page_ranges    An integer array which specifies the page ranges
 *                           to be imported from source PDF document.<br>
 *                           In this array, 2 numbers are a pair: the first integer is the starting page index,
 *                           and the second integer is the page count.<br>
 *                           If this parameter is set to <b>NULL</b>,
 *                           all pages in the source document will be imported.
 *                           If this parameter is not <b>NULL</b>, it should contains at least 2 numbers,
 *                           and the count of elements should be a multiples of 2.
 * @param[in] count          The count of elements in parameter <i>page_ranges</i>.
 *                           If parameter <i>page_ranges</i> is not <b>NULL</b>,
 *                           this value should be above 0 and be a multiples of 2.
 *                           If parameter <i>page_ranges</i> is <b>NULL</b>, this value will be ignored.
 * @param[in] pause          Pause object which decides if the importing process needs to be paused.
 *                           This can be <b>NULL</b> which means not to pause during the parsing process.
 *                           If this is not <b>NULL</b>, it should be a valid pause object impled by user.
 *
 * @details If the function {@link FSProgressive::GetRateOfProgress} return value is between 0 and 100,
 *         means the import pages process is not finished yet,
 *         and function {@link FSProgressive::Continue}
 *         should be called to continue the process.
 *         FSProgressive object should be deleted by user when progressive progress is finish<br>
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive* _Nullable)startImportPagesFromFilePath: (int)dstIndex flags: (FSImportFlags)flags layerName: (NSString *)layerName srcFilePath: (NSString *)srcFilePath password: (NSString * _Nullable)password pageRanges: (int *)pageRanges count: (int)count pause: (FSPauseCallback* _Nullable)pause;

/**
 * @brief Start to import pages from another PDF document (via file document).This is progressive, which means that the job may not finished when it return.
 *
 * @details Signed signatures in the pages of source PDF document will not be imported into current PDF document.
 *          Currently, if either current PDF document or the source PDF document contains XFA,
 *          not support to do the importing.
 *
 * @param[in] dest_index   A page index in current PDF document.
 *                         This is used to specify where the imported pages will be inserted.
 *                         If parameter <i>dest_index</i> is less than 0,
 *                         the imported pages will be inserted to the first. <br>
 *                         If parameter <i>dest_index</i> is equal to or larger than current page count,
 *                         the imported pages will be inserted to the end.
 * @param[in] flags        Options for importing pages.
 *                         It could be {@link FSImportFlags::e_importFlagNormal FSImportFlags::e_importFlagNormal}
 *                         or {@link FSImportFlags::e_importFlagWithLayers FSImportFlags::e_importFlagWithLayers}.
 *                         {@link FSImportFlags::e_importFlagShareStream FSImportFlags::e_importFlagShareStream}
 *                         would not take any effect.
 * @param[in] layer_name   The name of non-selectable label or the prefix name of the non-selectable label
 *                         to be shown in layer panel of application, in UTF-8 encoding.
 *                         If parameter <i>flags</i> contains
 *                         {@link FSImportFlags::e_importFlagWithLayers FSImportFlags::e_importFlagWithLayers},
 *                         this should not be empty and should be a valid string.
 *                         If parameter <i>flags</i> does not contain
 *                         {@link FSImportFlags::e_importFlagWithLayers FSImportFlags::e_importFlagWithLayers},
 *                         this string will be ignored.
 *                         <ul>
 *                         <li>If all the pages of source PDF document is to be imported to current document,
 *                             all layers from source document will be grouped under a non-selectable label,
 *                             and this string will be directly used as the label. </li>
 *                         <li>If only part of pages of source PDF document is to be imported to current document,
 *                             layers in the same page will be grouped under a single non-selectable label,
 *                             and this string will be used as the prefix name of the label.
 *                             The label will be like "layerName_Page_X". </li>
 *                         </ul>
 * @param[in] src_doc      A FSPDFDoc object that represents the source PDF document,
 *                         whose pages will be imported to current PDF document.
 *                         Please keep this source document valid until current document will not be saved any more.
 * @param[in] page_ranges  An integer array which specifies the page ranges
 *                         to be imported from source PDF document.<br>
 *                         In this array, 2 numbers are a pair: the first integer is the starting page index,
 *                         and the second integer is the page count.<br>
 *                         If this parameter is set to <b>NULL</b>,
 *                         all pages in the source document will be imported.
 *                         If this parameter is not <b>NULL</b>, it should contains at least 2 numbers,
 *                         and the count of elements should be a multiples of 2.
 * @param[in] count        The count of elements in parameter <i>page_ranges</i>.
 *                         If parameter <i>page_ranges</i> is not <b>NULL</b>,
 *                         this value should be above 0 and be a multiples of 2.
 *                         If parameter <i>page_ranges</i> is <b>NULL</b>, this value will be ignored.
 * @param[in] pause        Pause callback object which decides if the importing process needs to be paused.
 *                         This can be <b>NULL</b> which means not to pause during the parsing process.
 *                         If this is not <b>NULL</b>, it should be a valid pause object impled by user.
 *
 * @details If the function {@link FSProgressive::GetRateOfProgress} return value is between 0 and 100,
 *         means the import pages process is not finished yet,
 *         and function {@link FSProgressive::Continue}
 *         should be called to continue the process.
 *         FSProgressive object should be deleted by user when progressive progress is finish<br>
 *
 * @return A progressive object for later resuming the work, return nil if the work is already finished and no more work is required.
 */
-(FSProgressive* _Nullable)startImportPages: (int)dstIndex flags: (FSImportFlags)flags layerName: (NSString * _Nullable)layerName srcDoc: (FSPDFDoc *)srcDoc pageRanges: (int *)pageRanges count: (int)count pause: (FSPauseCallback* _Nullable)pause;


/**
 * @brief	Get PDF file version stored in PDF header section.
 *
 * @return	The file version, such as 14 for 1.4, 15 for 1.5, and etc.
 */
-(int)getFileVersion;
/**
 * @brief Specify the PDF file version which will be stored in PDF header section of the saved PDF file.
 *
 * @details The new file version will not affect on current document directly,
 *          but will be used in the saved PDF file in function {@link FSPDFDoc::saveAs}
 *          This function does not check whether the PDF matches the specified version.
 *
 * @param[in] version  An integer specify the file version, such as 14 for 1.4, 15 for 1.5, and etc.
 *                     Its value should be from 10 to 17 or 20 and be equal or greater than current version.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 *
 * @return None.
 */
-(void)setFileVersion: (int)version;

/**
 * @brief	Set a specified PDF security handler for encryption, such as standard encryption(password), certificate encryption...
 *
 * @param[in]	securityHandler		A PDF security handler object.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)setSecurityHandler:(FSSecurityHandler*)securityHandler;
/**
 * @brief	Get the current PDF security handler of current document.
 *
 * @return	The PDF security handler object.
 */
-(FSSecurityHandler*)getSecurityHandler;
/**
 * @brief	Remove the security handler from current document, so that the later saved document will be unencrypted.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeSecurity;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for Page parse status.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSPageParseFlag) {
    /** @brief	PDF page parsing flag for normal mode. */
    e_parsePageNormal = 0,
    /** @brief	PDF page parsing flag for text-only mode. */
    e_parsePageTextOnly = 1 << 0,
    /** @brief	Parse the text content of PDF page with outputting the hyphen on a line feed.*/
    e_parseTextOutputHyphen = 1 << 1
};

/**
 * @brief	Enumeration for calculating margin mode.
 *
 * @details	Values of this enumeration can be used alone.
 */
typedef NS_ENUM(NSUInteger, FSCalcMarginMode) {
    /** @brief	Calculate margin according to bounding box of all contents. */
    e_calcContentsBox = 0,
    /** @brief	Calculate margin by detecting paths or images. */
    e_calcDetection = 1
};


/**
 * @brief   Class to access graphics objects.
 *
 * @details This class is a manager for graphics objects. It stores all its graphics objects in a graphics list, and use a pointer to enumerate them.
 *          A pointer can be used to get one graphics object, insert new graphics object and even remove one.<br>
 *          If any graphics object is changed, or graphics object is inserted/removed, function {@link FSPDFGraphicsObjects::generateContent} should be called
 *          to ensure all these changes would be stored to PDF document.<br>
 *          A PDF page's content usually consists of a sequence of graphics objects, so class ::FSPDFPage is derived from class ::FSPDFGraphicsObjects in order that ::FSPDFPage can access its graphics object.<br>
 *          A form XObject, a kind of graphics object, is a self-contained description of any  sequence of graphics objects,
 *          so function {@link FSPDFFormXObject::getGraphicsObjects} can be used to retreive a ::FSPDFGraphicsObjects object from a form XObject
 *          in order to manage graphics objects which are contained in a form XObject.
 *
 * @see FSPDFPage
 * @see FSPDFFormXObject
 * @see FSPDFGraphicsObject
 */
@interface FSPDFGraphicsObjects : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Get the position of first graphics object in graphics object list, based on type filter.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FSGraphicsObjectType::e_graphicsObjTypeAll FSGraphicsObjectType::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FSGraphicsObjectType::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 *
 * @return  A pointer that represents the position of first graphics object in graphics object list.
 *          <b>nil</b> means there is no graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getFirstGraphicsObjectPosition: (FSGraphicsObjectType)filter;
/**
 * @brief   Get the position of last graphics object in graphics object list, based on type filter.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FSGraphicsObjectType::e_graphicsObjTypeAll FSGraphicsObjectType::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FSGraphicsObjectType::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 *
 * @return  A pointer that represents the position of last graphics object in graphics object list.
 *          <b>nil</b> means there is no graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getLastGraphicsObjectPosition: (FSGraphicsObjectType)filter;
/**
 * @brief   Get the position of next graphics object in graphics object list, based on type filter and specified current position.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FSGraphicsObjectType::e_graphicsObjTypeAll FSGraphicsObjectType::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FSGraphicsObjectType::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 * @param[in]   pos         A pointer that indicates a position in the graphics object list, whose next position is to be gotten. It should not be <b>nil</b>
 *
 * @return  A pointer that represents the position of next graphics object in graphics object list.
 *          <b>nil</b> means parameter <i>position</i> is the last position in graphics object list, or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getNextGraphicsObjectPosition: (FSGraphicsObjectType)filter pos: (void*)pos;
/**
 * @brief   Get the position of previous graphics object in graphics object list, based on type filter and specified current position.
 *
 * @details After getting a position in the graphics object list, then user can call function {@link FSPDFGraphicsObjects::getGraphicsObject:} to get the graphics object with this position.
 *
 * @param[in]   filter      Type filter that specifies which kind of graphics object is to be gotten.
 *                          Please refer to {@link FSGraphicsObjectType::e_graphicsObjTypeAll FSGraphicsObjectType::e_graphicsObjTypeXXX} values and it should be one of these values.
 *                          {@link FSGraphicsObjectType::e_graphicsObjTypeAll} means for all kinds of graphics objects.
 * @param[in]   pos         A pointer that indicates a position in the graphics object list, whose previous position is to be gotten. It should not be <b>nil</b>
 *
 * @return  A pointer that represents the position of previous graphics object in graphics object list.
 *          <b>nil</b> means parameter <i>position</i> is already in the first position in graphics object list, or there is any error.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)getPrevGraphicsObjectPosition: (FSGraphicsObjectType)filter pos: (void*)pos;
/**
 * @brief   Get the graphics object by position in graphics object list.
 *
 * @param[in]   pos     A pointer that indicates the position in the graphics object list.
 *                      It should not be <b>nil</b> and should be returned by function {@link FSPDFGraphicsObjects::getNextGraphicsObjectPosition:pos:}.
 *
 * @return  A ::FSPDFGraphicsObject object.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSPDFGraphicsObject*)getGraphicsObject: (void*)pos;
/**
 * @brief   Insert a graphics object after the specified position.
 *
 * @param[in]   posInsertAfter      Used to specify the position, in order to insert parameter <i>graphicsObj</i> after this position.
 *                                  <b>nil</b> means that parameter <i>graphicsObj</i> will be inserted before all objects, ignoring the specified type filter.
 * @param[in]   graphicsObj         A graphics object to be inserted. User should ensure that parameter <i>graphicsObj</i> belongs to the same PDF document as current graphics objects.
 *
 * @return  The new position of the inserted graphics object.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void*)insertGraphicsObject: (void*)posInsertAfter graphicsObj: (FSPDFGraphicsObject*)graphicsObj;
/**
 * @brief   Remove a graphics object.
 *
 * @details To remove a graphics object by position (function {@link FSPDFGraphicsObjects::removeGraphicsObjectByPosition:})
 *          is more direct and effective than to remove a graphics object directly (function {@link FSPDFGraphicsObjects::removeGraphicsObject:}).
 *
 * @param[in]   graphicsObj A graphics object to be removed.
 *                          Please ensure this graphics object belongs to current graphics objects.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeGraphicsObject: (FSPDFGraphicsObject*)graphicsObj;
/**
 * @brief   Remove a graphics object by position.
 *
 * @details To remove a graphics object by position (function {@link FSPDFGraphicsObjects::removeGraphicsObjectByPosition:})
 *          is more direct and effective than to remove a graphics object directly (function {@link FSPDFGraphicsObjects::removeGraphicsObject:}).
 *
 * @param[in]   pos     Used to specify the position of a graphics object, to be removed.
 *                      It should not be <b>nil</b>.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeGraphicsObjectByPosition: (void*)pos;
/**
 * @brief   Generate contents of current graphics objects.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)generateContent;

-(void)dealloc;

@end

/**
 * @brief	Class to access a PDF page.
 *
 * @details	Usually, a ::FSPDFPage object is retrieved from a PDF document by function {@link FSPDFDoc::getPage:}
 *			Function {@link FSPDFPage::isParsed} is used to judge whether the PDF page has been parsed or not.
 *			For a un-parsed page, use function {@link FSPDFPage::startParse:pause:isReparse:} to parse it.<br>
 *			This class offers functions to access data of a PDF page, such as page width/height, page rotation, display matrix and so on.
 *			It also offers functions to access PDF annotations:
 *			<ul>
 *			<li>To get a PDF annotation, use function {@link FSPDFPage::getAnnot:}, {@link FSPDFPage::getAnnotAtPos:tolerance:},
 *				or {@link FSPDFPage::getAnnotAtDevicePos:position:tolerance:}.</li>
 *			<li>To add a new PDF annotation, use function {@link FSPDFPage::addAnnot:rect:}.</li>
 *			<li>To remove a PDF annotation, use function {@link FSPDFPage::removeAnnot:}.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 * @see FSAnnot
 */
@interface FSPDFPage : FSPDFGraphicsObjects

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the PDF document, which current PDF page belongs to.
 *
 * @return	Related PDF document.
 */
-(FSPDFDoc*)getDocument;
/**
 * @brief	Get the page dictionary.
 *
 * @return	Page dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getDict;
/**
 * @brief	Check if current page has been parsed or not.
 *
 * @return	<b>YES</b> means current page has been parsed, while <b>NO</b> means current page has not been parsed yet.
 */
-(BOOL)isParsed;
/**
 * @brief Start to parse current page.This is progressive, which means that the job may not finished when it return.
 *
 * @param[in] flags        Parsing  flags.
 *                        Please refer to {@link FSPageParseFlag::e_parsePageNormal FSPageParseFlag::e_parsePageXXX}
 *                        values and this should be one or a combination of these values.
 * @param[in] pause       Pause callback object which decides if the parsing process needs to be paused.
 *                        This can be <b>NULL</b> which means not to pause during the parsing process.
 *                        If this is not <b>NULL</b>, it should be a valid pause object impled by user.
 * @param[in] isReparse  <b>true</b> means to re-parse current page,
 *                        while <b>false</b> means do not re-parse current page.
 *
 * @return A progressive object:
 *         <ul>
 *         <li>If the returned object is not <b>NULL</b>, that means the progress needs to be continued.
 *             Please call function {@link FSProgressive::Continue} to coninue the progress until it is finished.
 *             After the progress is finished, user should remember to delete the returned progressive object.
 *         </li>
 *         <li>If the returned object is <b>NUL</b>, that means the progress has been finished.</li>
 *         </ul>
 *
 * @note When parameter <i>isReparse</i> is set to <b>true</b>, that means to re-parse current PDF page,
 *       and all the retrieved graphics object's position (as FS_POSITION object) and graphics object (as
 *       FSPDFGraphicsObject object) will be invalid.<br>
 *       Application needs to get graphics objects again after re-parsing a PDF page.
 *
 */
-(FSProgressive * _Nullable)startParse: (FSPageParseFlag)flag pause: (FSPauseCallback* _Nullable)pause isReparse: (BOOL)isReparse;
/**
 * @brief	Get page index.
 *
 * @return	Page index, starting from 0.
 */
-(int)getIndex;
/**
 * @brief	Get the page height.
 *
 * @return	Page height.
 */
-(float)getHeight;
/**
 * @brief	Get the page width.
 *
 * @return	Page width
 */
-(float)getWidth;
/**
 * @brief	Get the page rotation.
 *
 * @return	Page rotation value.
 *			Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and this would be one of these values.
 */
-(FSRotation)getRotation;
/**
 * @brief	Load the thumbnail bitmap.
 *
 * @return	Thumbnail bitmap.<br>
 *			If no thumbnail can be found or there is any error, this function will return <b>nil</b>.<br>
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSBitmap*)loadThumbnail;
/**
 * @brief	Get the display matrix of PDF page, from PDF coordinate system to targeted device coordinate system.
 *
 * @param[in]	xPos	Left position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	yPos	Top position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	xSize	Width of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	ySize	Height of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	rotate	Rotation value.
 *						Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and this would be one of these values.
 *
 * @return	Display matrix.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSMatrix*)getDisplayMatrix: (int)xPos yPos: (int)yPos xSize: (int)xSize ySize: (int)ySize rotate: (FSRotation)rotate;
/**
 * @brief	Calculate the content area of PDF page.
 *
 * @param[in]	mode	Calculation mode. It should be one of following values:
 *						<ul>
 *						<li>{@link FSCalcMarginMode::e_calcContentsBox} means calculate margin according to bounding box of all contents.</li>
 * 						<li>{@link FSCalcMarginMode::e_calcDetection} means calculate margin by detecting paths or images.</li>
 *						</ul>
 *
 * @return	The minimal rectangle which contains the visible page content.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSRectF*)calcContentBBox: (FSCalcMarginMode)mode;
/**
 * @brief	Get the count of annotations.
 *
 * @return	The count of the annotations.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getAnnotCount;
/**
 * @brief	Get an annotation by index.
 *
 * @param[in]	index	Annotation index. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPage::getAnnotCount}.
 *
 * @return	An annotation instance.
 *			If there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)getAnnot: (int)index;
/**
 * @brief	Get the annotation at a specific position, in PDF coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	pos			The specific position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot* _Nullable)getAnnotAtPos: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Get the annotation at a specific position, in device coordination system.
 *
 * @details	If there are several annotations in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	matrix		The transformation matrix. Usually this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *							If this is <b>nil</b>, current function will have the same feature as function {@link FSPDFPage::getAnnotAtPos:tolerance:}.
 * @param[in]	pos			The specific position, in device coordinate system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	A ::FSAnnot object.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot* _Nullable)getAnnotAtDevicePos:(const FSMatrix*)matrix position: (FSPointF*)pos tolerance: (float)tolerance;
/**
 * @brief	Add an annotation to PDF page.
 *
 * @details	Currently, this function can support to add most annotation types except:<br>
 *			Widget, Sound, Movie, Screen, PrinterMark, TrapNet, Watermark, 3D, PSInk.<br>
 *			Attention:
 *			<ul>
 *			<li>Specially, widget annotations are used to represent as form controls of form field, including signature field. <br>
 *				For signature field, function {@link FSPDFPage::addSignature:} can be called to add a new signature object. <br>
 *				For other types of form field, not support to add them yet.<br>
 *			</li>
 *			<li>For supported annotations types, if user does not set any properties of the newly created annotation (except the required properties)
 *				and directly calls function {@link FSAnnot::resetAppearanceStream}, default appearance will be used.
 *				Please refer to comment of concrete annotation class for more details of their own default appearance.
 *			</li>
 *			</ul>
 *
 * @param[in]	annotType	The type of annotation to be added.
 *							Currently, only support:<br>
 *							{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline},
 *							{@link FSM_ANNOTTYPE::e_annotSquiggly}, {@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotLink},
 *							{@link FSM_ANNOTTYPE::e_annotSquare}, {@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText},
 *							{@link FSM_ANNOTTYPE::e_annotStamp}, {@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotInk},
 *							{@link FSM_ANNOTTYPE::e_annotLine}, {@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine},
 *							{@link FSM_ANNOTTYPE::e_annotFileAttachment}, {@link FSM_ANNOTTYPE::e_annotPopup}.
 * @param[in]	rect		Rectangle of the new annotation.
 *							<ul>
 *							<li>For annotation in following type, they needs a valid rectangle when being added. So for them, <i>rect</i> should be valid:<br>
 *								{@link FSM_ANNOTTYPE::e_annotNote}, {@link FSM_ANNOTTYPE::e_annotLink}, {@link FSM_ANNOTTYPE::e_annotSquare},
 *								{@link FSM_ANNOTTYPE::e_annotCircle}, {@link FSM_ANNOTTYPE::e_annotFreeText}, {@link FSM_ANNOTTYPE::e_annotStamp},
 *								{@link FSM_ANNOTTYPE::e_annotCaret}, {@link FSM_ANNOTTYPE::e_annotFileAttachment}.</li>
 *							<li>For annotation in following type, their rectangle will be updated when other required properties of them have been set.
 *								So for them, <i>rect</i> can be an empty rectangle:<br>
 *								{@link FSM_ANNOTTYPE::e_annotHighlight}, {@link FSM_ANNOTTYPE::e_annotUnderline}, {@link FSM_ANNOTTYPE::e_annotSquiggly},
 *								{@link FSM_ANNOTTYPE::e_annotStrikeOut}, {@link FSM_ANNOTTYPE::e_annotInk}, {@link FSM_ANNOTTYPE::e_annotLine},
 *								{@link FSM_ANNOTTYPE::e_annotPolygon}, {@link FSM_ANNOTTYPE::e_annotPolyLine}, {@link FSM_ANNOTTYPE::e_annotPopup}.<br>
 *								If an invalid rectangle is passed to <i>rect</i>, an empty rectangle will be used instead.</li>
 *							</ul>
 *
 * @return	A ::FSAnnot object that receives the newly created annotation.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSAnnot*)addAnnot: (FSAnnotType)annotType rect: (FSRectF*)rect;
/**
 * @brief	Remove an annotation.
 *
 * @param[in]	annot	An annotation to be removed. It should be in current PDF page.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)removeAnnot: (FSAnnot*)annot;
/**
 * @brief	Check whether current PDF page has transparency or not.
 *
 * @return	<b>YES</b> means current page has transparency, while <b>NO</b> means current page does not have transparency.
 *
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(BOOL)hasTransparency;

/**
 * @brief	Flatten current PDF page: annotations or form fields may be made to be a part of the page contents according to specified options.
 *
 * @details     After flattening current page successfully, user should re-parse this page by function {@link FSPDFPage::startParse:pause:isReparse:}.
 *
 * @param[in]	isDisplay	The flatten flags:
 *							<b>YES</b> means the flatten result is used for display, and <b>NO</b> means the flatten result is used for print.
 * @param[in]	options		The flatten options.
 *							Please refer to {@link FSFlattenOptions::e_flattenOptionAll FSFlattenOptions::e_flattenOptionXXX} values and it should one
 *                                  or a combination of them.<br>
 *							Specially, if {@link FSFlattenOptions::e_flattenOptionNoAnnot} and {@link FSFlattenOptions::e_flattenOptionNoFormControl}
 *                                  are used together,
 *							that means nothing is to be flatten to page and this function will return <b>YES</b> directly.
 *
 * @return	<b>YES</b> means current page is flattened successfully, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)flatten:(BOOL)isDisplay options:(FSFlattenOptions)options;
/**
 * @brief	Group all the input markup annotations together.
 *
 * @details	Markup annotations can be grouped. The group consists of a primary annotation and one or more subordinate annotations.
 *			Some entries in the primary annotation are treated as group attributes that should apply to the group as a whole;
 *			the corresponding entries in the subordinate annotations should be ignored. These entries are contents, last modification time,
 *			fill color/border color, title, pop-up annotation, creation time, subject, and open status.
 *			So user should respect the group property: when a property of an annotation in the group is changed,
 *			the other annotations in the same group should be changed too.<br>
 *			Operations that manipulate any annotation in a group, such as movement, cut, and copy,
 *			should be treated by viewer applications as acting on the entire group.
 *
 * @param[in]	annotArray		A markup annotation object array that specifies markup annotations which are to be grouped together.
 *								This array should contains at least 2 markup annotations, and all the markup annotations in this array should be different from others.
 *								All the markup annotations in this array should be in current page. <br>
 *								Specially, if a markup annotation in this array is already in another group, that group will be set to the new group with the new header as well.
 * @param[in]	headerIndex		The index that specifies a markup annotation in parameter <i>annotArray</i> to be the header of the group.
 *								Valid range: from 0 to (<i>arrayCount</i> -1).
 *
 * @return	<b>YES</b> means group input markup annotations together successfully,
 *			while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)setAnnotGroup: (NSArray<FSMarkup*>*)annotArray  headerIndex: (int)headerIndex;

/**
 * @brief	Add a signature to PDF page.
 *
 * @param[in]	rect		Rectangle position for the new signature, in PDF coordinate system.
 *
 * @return	A ::FSSignature object that receives the newly created signature.
 *			If there is any error, <b>nil</b> will be returned.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSSignature*)addSignature: (FSRectF*)rect;
/**
 * @brief Check whether the current page has any watermark, not including Foxit PDF SDK trial watermark.
 *
 * @details Before using this function, please ensure current page has been parsed.
 *
 * @return <b>true</b> means the current page has watermark, and <b>false</b> means the current page has no watermark.
 */
-(BOOL)hasWatermark;
/**
 * @brief Remove all watermarks.
 *
 * @details Before using this function, please ensure current page has been parsed.
 *
 * @return <b>true</b> means success, while <b>false</b> means failure.
 */
-(BOOL)removeAllWatermarks;
/**
 * @brief	Set page rotation.
 *
 * @param[in]	rotate	New page rotation value.
 *						Please refer to {@link FSRotation::e_rotation0 FSRotation::e_rotationXXX} values and this should be one of these values.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setRotation: (FSRotation)rotate;
/**
 * @brief	Set page width and height.
 *
 * @details	New page width and height should be positive values.
 *			If current page is a newly create PDF page by function {@link FSPDFDoc::insertPage:}, current page can be set with any valid new size values.
 *			If current page is gotten from PDF document, the new page size should not be greater than the original one.
 *
 * @param[in]	width	New page width. It should be a positive value and the unit is 1/72 inch.
 * @param[in]	height	New page height. It should be a positive value and the unit is 1/72 inch.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setSize: (float)width height: (float)height;
/**
 * @brief	Set page box.
 *
 * @param[in]	boxType		Page box type.
 *							Please refer to {@link FSPageBoxType::e_pageMediaBox FSPageBoxType::e_pageXXXBox} values and it should be one of these values.
 * @param[in]	box			New box rectangle, in PDF coordinate system.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setBox: (FSPageBoxType)boxType box: (FSRectF*)box;
/**
 * @brief Get page box.
 *
 * @param[in] box_type  Page  box type.
 *                      Please refer to {@link FSPageBoxType::e_pageMediaBox FSPageBoxType::e_pageXXXBox}
 *                      values and it should be one of these values.
 *
 * @return A box rectangle, in PDF coordinate system.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(FSRectF*)GetBox:(FSPageBoxType)box_type;

/**
 * @brief	Transform a PDF page, including the annotations and form fields on the page.
 *
 * @note	This function only supports scaling and translating.
 *			After this operation, please re-parse current page by function {@link FSPDFPage::startParse:pause:isReparse:} with parameter <i>isReparse</i> <b>YES</b>,
 *			in order that expected content will be displayed.
 *
 * @param[in]	matrix					Transform matrix.
 * @param[in]	needTransformClipPath	<b>YES</b> means to transform the page with clip rectangle, and <b>NO</b> means not.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)transform: (FSMatrix*)matrix needTransformClipPath: (BOOL)needTransformClipPath;
/**
 * @brief	Set clip rectangle for all page objects on current PDF page.
 *
 * @details	After this function finishes successfully, please re-parse current page by function {@link FSPDFPage::startParse:pause:isReparse:} with parameter <i>isReparse</i> <b>YES</b>.
 *
 * @param[in]	clipRect		New clip rectangle, in PDF coordinate system.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setClipRect: (FSRectF*)clipRect;
/**
 * @brief	Set page thumbnail.
 *
 * @details	Thumbnail image does not use alpha channel. So user is recommended to set a bitmap without alpha channel to be the new thumbnail image.
 *			If a bitmap with alpha channel is set, the new thumbnail will use white background by default.
 *
 * @param[in]	thumbnail		New page thumbnail.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setThumbnail: (FSBitmap*)thumbnail;

/**
 * @brief	Add an image to current page from file path.
 *
 * @details	The image added is the first frame acquiescently. Supported image types are jpg/png/gif/jpx/bmp/tif.
 *
 * @param[in]	imageFilePath		An image file path, including extension name. It should be in UTF-8 encoding and should not be <b>nil</b> or empty.
 * @param[in]	posPoint			The specific position, in PDF coordination system.
 * @param[in]	width				The width set into page. The value should be larger than 0.
 * @param[in]	height				The height set into page.The value should be larger than 0.
 * @param[in]	isGenerateContent	A boolean value that indicates whether to generate content for page internally or not.
 *									<b>YES</b> means to generate content internally,
 *									When using <b>NO</b>, user should ensure to call function {@link FSPDFPage::generateContent} after adding image.
 *									In order to improve efficiency, users can call {@link FSPDFPage::generateContent} once after adding image many times.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(BOOL)addImageFromFilePath: (NSString *)imageFilePath posPoint: (FSPointF*)posPoint width: (float)width height: (float)height isGenerateContent:(BOOL)isGenerateContent;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *									Bookmark													*
 *************************************************************************************************/

/**
 * @brief	Enumeration for bookmark style type.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
typedef NS_OPTIONS(NSUInteger, FSBookmarkStyle){
    /** @brief	 Show bookmark title as normal text. */
    e_bookmarkStyleNormal = 0,
    /** @brief	 Show bookmark title as italic text. */
    e_bookmarkStyleItalic = 1,
    /** @brief	 Show bookmark title as bold text. */
    e_bookmarkStyleBold = 1 << 1
};
/**
 * @brief	Enumeration for bookmark position.
 *
 * @details	Values of this enumeration should be used alone.<br>
 *			Actually, "bookmark position" means the relationship between current bookmark and another bookmark.
 */
typedef NS_ENUM(NSUInteger, FSBookmarkPosition){
    /** @brief	 Position as first child. */
    e_bookmarkPosFirstChild	= 0,
    /** @brief	 Position as last child. */
    e_bookmarkPosLastChild,
    /** @brief	Position as previous sibling. */
    e_bookmarkPosPrevSibling,
    /** @brief	Position as next sibling. */
    e_bookmarkPosNextSibling,
    /** @brief	Position as first sibling. */
    e_bookmarkPosFirstSibling,
    /** @brief	Position as last sibling. */
    e_bookmarkPosLastSibling
};
/**
 * @brief	Class to access a PDF bookmark.
 *
 * @details	PDF bookmark is also called "outline". It's a tree-structured hierarchy. It allows user to navigate PDF document easily by selecting one outline.
 *			One bookmark contains a destination or actions to indicate how to response when user selects it.<br>
 *			In order to access the bookmark tree, function {@link FSPDFDoc::getFirstBookmark} must be called first to get the root of the whole bookmark tree.
 *			If the "root bookmark" does not exist, function {@link FSPDFDoc::createFirstBookmark} could be called to create a new "root bookmark".
 *			Here, "root bookmark" is an abstract object. "root bookmark" can only have some child bookmarks but no parent, no next sibling bookmarks or any data
 *			(including bookmark data, destination data and action data). And "root bookmark" cannot be shown on the application UI since it has no data.
 *			So, for a root bookmark, only function {@link FSBookmark::getFirstChild} can be used.<br>
 *			From the root bookmark, the bookmark tree can be traversed and each bookmark node can be accessed.<br>
 *			This class offers several functions to access other bookmarks from current bookmark. For example:
 *			<ul>
 *			<li>To access the parent bookmark, use function {@link FSBookmark::getParent}.</li>
 *			<li>To access the first child bookmark, use function {@link FSBookmark::getFirstChild}.</li>
 *			<li>To access the next sibling bookmark, use function {@link FSBookmark::getNextSibling}.</li>
 *			<li>To insert a new bookmark, use function {@link FSBookmark::insert:pos:}.</li>
 *			<li>To move a bookmark, use function {@link FSBookmark::moveTo:pos:}. </li>
 *			</ul>
 *			This class also offers functions to access the data of a PDF bookmark.
 *
 * @see	FSPDFDoc
 */
@interface FSBookmark : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the parent bookmark.
 *
 * @return	The parent bookmark instance.
 */
-(FSBookmark* _Nullable)getParent;
/**
 * @brief	Get the first child bookmark.
 *
 * @return	The first child bookmark instance.
 */
-(FSBookmark* _Nullable)getFirstChild;
/**
 * @brief	Get the next sibling bookmark.
 *
 * @return	The next sibling bookmark instance.
 */
-(FSBookmark* _Nullable)getNextSibling;
/**
 * @brief	Insert a new bookmark according to the position.
 *
 * @details	For the new bookmark, the color be 0xFF000000 and the style would be {@link FSBookmarkStyle::e_bookmarkStyleNormal} by default.<br>
 *
 * @param[in]	title	Title string for the new bookmark. It should be UTF-8 encoding.
 * @param[in]	pos		The position where the new bookmark item is to be inserted, based on current bookmark.
 *						Please refer to {@link FSBookmarkPosition::e_bookmarkPosFirstChild FSBookmarkPosition::e_bookmarkPosXXX} values and it would be one of these values.<br>
 *						If current bookmark is just the "root bookmark", parameter <i>pos</i> can only be {@link FSBookmarkPosition::e_bookmarkPosFirstChild} or {@link FSBookmarkPosition::e_bookmarkPosLastChild}.
 *
 * @return	A new bookmark object.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSBookmark*)insert: (NSString*)title  pos: (FSBookmarkPosition)pos;


/**
 * @brief Move current bookmark to be child or sibling of another bookmark.
 *
 * @details If current bookmark is returned by function {@link FSPDFDoc::GetFirstBookmark}
 *          or {@link FSPDFDoc::CreateFirstBookmark}, that means it is the "root bookmark",
 *          and it cannot be moved to be child or sibling of any bookmark in the bookmark tree.
 *          In this case, this function will return <b>false</b> directly.
 *
 * @param[in] dest_bookmark  The destination bookmark. It should not be current bookmark itself or
 *                           any descendant of current bookmark.<br>
 *                           Current bookmark will be moved to be child or sibling of the destination bookmark.
 * @param[in] position       The position where the current bookmark is to be moved to,
 *                           based on parameter <i>destBookmark</i>. Please refer to
 *                           {@link foxit::e_bookmarkPosFirstChild FSBookmarkPosition::e_bookmarkPosXXX}
 *                           values and it would be one of these values.
 *
 * @return <b>true</b> means success, while <b>false</b> means failure.
 *
 * @throws FSException For more information about exception values,
 *                     please refer to {@link foxit::e_errFile FSErrorCode::e_errXXX}.
 */
-(BOOL)moveTo: (FSBookmark*)destBookmark  pos: (FSBookmarkPosition)pos;
/**
 * @brief	Get the destination of the bookmark.
 *
 * @details	If current bookmark dictionary has /Dest or a goto action (/A), this function can get the destination information directly.
 *			If current bookmark dictionary does not have /Dest or its /A is not a goto action,
 *			no destination information can be retrieved and this function will return <b>nil</b>.
 *
 * @return	The destination instance.
 */
-(FSDestination*)getDestination;
/**
 * @brief	Set the destination.
 *
 * @param[in]	dest	The new destination.
 */
-(void)setDestination: (FSDestination*)dest;
/**
 * @brief	Get the title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get the color.
 *
 * @return	Color used for displaying title.
 *			Format: 0xAARRGGBB. Alpha value is ignored and will always be 0xFF by default.
 */
-(unsigned int)getColor;
/**
 * @brief	Set the color.
 *
 * @param[in]	color	Color used for displaying title. Format:0xAARRGGBB.
 *						Alpha value is ignored and will always be treated as 0xFF internally.
 */
-(void)setColor: (unsigned int)color;
/**
 * @brief	Get bookmark style.
 *
 * @return	The bookmark style values.
 *			This would be one or a combination of {@link FSBookmarkStyle::e_bookmarkStyleNormal FSBookmarkStyle::e_bookmarkStyleXXX} values.
 */
-(FSBookmarkStyle)getStyle;
/**
 * @brief	Set bookmark style.
 *
 * @param[in]	style	The style of the bookmark. This can be one or a combination of {@link FSBookmarkStyle::e_bookmarkStyleNormal FSBookmarkStyle::e_bookmarkStyleXXX} values.
 *						If the <i>style</i> is invalid, {@link FSBookmarkStyle::e_bookmarkStyleNormal} will be set instead.
 */
-(void)setStyle: (FSBookmarkStyle)style;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *									FSReadingBookmark											*
 *************************************************************************************************/

/**
 * @brief	Class to access a reading bookmark.
 *
 * @details	Reading bookmark is not a PDF bookmark, in other words, it is not PDF outlines.
 *			It is the bookmark in applicable level. It is stored in the metadata (XML format) of catalog.
 *			It allows user to add or remove a reading bookmark according to their reading preferences and
 *			navigate one PDF page easily by selecting one reading bookmark.<br>
 *			In order to access the reading bookmark,
 *			function {@link FSPDFDoc::getReadingBookmarkCount} could be called to count the reading bookmarks,
 *			and function {@link FSPDFDoc::getReadingBookmark:} could be called to get a reading bookmark by index.
 *			This class offers several functions to access properties of reading bookmarks. For example:
 *			<ul>
 *			<li>To access the title of reading bookmark, use function {@link FSReadingBookmark::getTitle}.</li>
 *			<li>To set or rename the title, use function {@link FSReadingBookmark::setTitle:}.</li>
 *			<li>To access the page index of reading bookmark, use function {@link FSReadingBookmark::getPageIndex}.</li>
 *			<li>To set the page index, use function {@link FSReadingBookmark::setPageIndex:}.</li>
 *			</ul>
 *
 * @see	FSPDFDoc
 */
@interface FSReadingBookmark : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the title.
 *
 * @return	Title string, in UTF-8 encoding.
 *			If no title property can be found or there is any error, this function will return an empty string.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(NSString*) getTitle;

/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string. It should be in UTF-8 encoding.
 *
 * @return	None.
 *
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setTitle:(NSString*)title;

/**
 * @brief	Get the index of the destination page.
 *
 * @return	The page index, starting from 0.
 *			If no page index property can be found or there is any error, this function will return -1.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(int)getPageIndex;

/**
 * @brief	Set the index of the destination page.
 *
 * @param[in]	index	The new destination page index.
 *
 * @return	None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setPageIndex:(int)index;

/**
 * @brief	Get date and time.
 *
 * @param[in]	isCreationDate		<b>YES</b> means to get creation date time, and <b>NO</b> means to get modified date time.
 *
 * @return	The specified date and time.
 *			If no specified date and time property can be found or there is any error,
 *			this function will return a ::FSDateTime object with all values 0.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(FSDateTime *)getDateTime:(BOOL)isCreationDate;

/**
 * @brief	Set date and time.
 *
 * @param[in]	dateTime		New date and time. Its value should be valid.
 * @param[in]	isCreationDate	<b>YES</b> means to set creation date time, and <b>NO</b> means to set modified date time.
 *
 * return None.
 *
 * @exception	An exception will be thrown on failure.
 *				For more information about exception values, please refere to FS_ERRCODE::e_errXXX.
 */
-(void)setDateTime:(FSDateTime * _Nonnull)dateTime isCreationDate:(BOOL)isCreationDate;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for name tree type.
 *
 * @details	Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSNameTreeType) {
    /** @brief	"Dests" name tree. */ 
    e_nameTreeDests = 1,
    /** @brief	"JavaScript" name tree. */
    e_nameTreeJavaScript,
    /** @brief	"EmbeddedFiles" name tree. */
    e_nameTreeEmbeddedFiles
};

/**
 * @brief	Class to access a PDF name tree.
 *
 * @details	Name tree is a kind of common data structure in PDF. Name tree serves a similar purpose to PDF dictionary - associating keys and
 *			values - but by different means: in the name tree, a key is treated as an alias of its value object.
 *			That means, the value object can be referred to by the key name instead of by reference object.<br>
 *			Name tree has following characteristics:<br>
 *			keys in a name tree are ordered and each key in the same name tree is unique; values associated with the keys may be objects of any type,
 *			depending on the purpose of the name tree; name tree can represent an arbitrarily large collection of key-value pairs,
 *			which can be looked up efficiently without requiring the entire data structure to be read from the PDF file.<br>
 *			Class {@link FSPDFNameTree} is used to access an existing name tree with specified type or create one. It offers methods to access key-value pairs in the name tree,
 *			and set/add/remove any key-value pair.
 *			Currently, class {@link FSPDFNameTree} can support to access to following name trees:
 *			<ul>
 *			<li>Destinations name tree (with type {@link FSNameTreeType::e_nameTreeDests}), which maps name strings to destinations.
 *				Values in this name tree should be a destination array (or a reference object to destination array).
 *			</li>
 *			<li>JavaScript name tree (with type {@link FSNameTreeType::e_nameTreeJavaScript}), which maps name strings to document-level JavaScript actions.
 *				Values in this name tree should be a javascript action dictionary (or a reference object to javascript action dictionary).
 *			</li>
 *			<li>EmbeddedFiles name tree, with type {@link FSNameTreeType::e_nameTreeEmbeddedFiles}, which maps name strings to file specifications for embedded file streams.
 *				Values in this name tree should be a file specification dictionary (or a reference object to file specification dictionary), which contains an embedded file stream.
 *			</li>
 *			</ul>
 */
@interface FSPDFNameTree : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

-(id)init NS_UNAVAILABLE;
/**
 * @brief	Create a {@link FSPDFNameTree} object to access to a specified type name tree in the PDF document.
 *
 * @details	{@link FSPDFNameTree} can be used to access to an existed name tree, or create a new name tree if no name tree exists in the document.
 *
 * @param[in]	pdfDoc		A FSPDFDoc object, it should be valid.
 * @param[in]	type		The type of the name tree.
 *							Please refer to {@link FSNameTreeType::e_nameTreeDests FSNameTreeType::e_nameTreeXXX} values and it should be one of these values.
 *
 * @return	A {@link FSPDFNameTree} object.
 */
- (FSPDFNameTree *)initWithPDFDoc:(FSPDFDoc *)pdfDoc type:(FSNameTreeType)type;
/**
 * @brief	Check if the specified name exists in current name tree.
 *
 * @param[in]	name		String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *
 * @return	<b>TRUE</b> means the specified name exists in current name tree,
 *			and <b>FALSE</b> means the specified name does not exist in current name tree.
 *
 * @exception	e_errParam		Value of any input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(BOOL)hasName: (NSString*)name;
/**
 * @brief	Get the count of elements in current name tree.
 *
 * @return	The count.
 */
-(int)getCount;
/**
 * @brief	Get a name in the name tree, by index.
 *
 * @param[in]	index	Index of the name to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFNameTree::getCount}.
 *
 * @return	A name string, in UTF-8 encoding.
 *
 */
-(NSString*)getName: (int)index;
/**
 * @brief	Get the value (as PDF object) of a specified name.
 *
 * @param[in]	name		String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *
 * @return	A FSPDFObject object. <br>
 *			The type of returned PDF object depends on the purpose of current name tree. Please refer to comment of class {@link FSPDFNameTree} for more details.
 *
 */
-(FSPDFObject*)getObj: (NSString*)name;
/**
 * @brief	Get the value (as PDF object) of a specified name.
 *
 * @param[in]	name	String of the name, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *						This name should have existed in current name tree.
 * @param[in]	pdfObj	The new PDF object to set to the name's value. It should be valid.
 *						The type of this PDF object should match current name tree; otherwise, the input PDF object is invlid.
 *						Please refer to comment of class {@link FSPDFNameTree} for more details.<br>
 *						User should not release this PDF object after this function succeeds.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)setObj: (NSString*)name pdfObj: (FSPDFObject*)pdfObj;
/**
 * @brief	Rename an existing name to a new name.
 *
 * @param[in]	oldName		String of an old name which is to be renamed. This string should be in UTF-8 encoding and should not be <b>NULL</b> or empty.
 *							This name should have existed in current name tree.
 * @param[in]	newName		String of a new name, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should not have existed in current name tree.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)rename: (NSString*)oldName newName: (NSString*)newName;
/**
 * @brief	Add a new name with a PDF object as its value.
 *
 * @details	All names (as keys) in a name tree should be ordered. When the new name is added, Foxit PDF SDK will find a suitable place in the name tree to add it.
 *			After adding successfully, the indexes of some old names may be changed.
 *
 * @param[in]	name		String of a new name, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should not have existed in current name tree.
 * @param[in]	pdfObj		A PDF object, to be set with the new name.
 *							The type of this PDF object should match current name tree; otherwise, the input PDF object is invlid.
 *							Please refer to comment of class {@link FSPDFNameTree} for more details.<br>
 *							User should not release this PDF object after this function succeeds.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 */
-(BOOL)add: (NSString*)name pdfObj: (FSPDFObject*)pdfObj;
/**
 * @brief	Remove a name from current name tree, along with its value (as PDF object).
 *
 * @details	If the input name does not exist in current name tree, this function will return <b>TRUE</b> directly.
 *
 * @param[in]	name		String of a name to be removed, in UTF-8 encoding. This should not be <b>NULL</b> or empty.
 *							This new name should have existed in current name tree.
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 *
 * @exception	e_errParam		Value of any input parameter is invalid.
 * @exception	e_errFormat		Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(BOOL)removeObj: (NSString*)name;
/**
 * @brief	Remove all names from current name tree, along with theirs value (as PDF object).
 *
 * @return	<b>TRUE</b> means success, while <b>FALSE</b> means failure.
 */
-(BOOL)removeAllObjs;
/**@brief Default initialization. */

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief Class to represent information of a page labeling range.
 *
 * @see PDF Reference 1.7 Section 8.3.1 Page Labels
 */
@interface FSPDFPageLabels : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief Construct from a PDF document object.
 *
 * @details If there exists page labeling range information information in the specified PDF document,
 *          this function is just to construct a FSPDFPageLabels object to be associated with these information.
 *          If there is no such information in the specified PDF document, the constructed FSPDFPageLabels object
 *          can be used to set page labeling range information to PDF document.
 *
 * @param[in] document  A PDF document object. It should be valid and should not be <b>NULL</b>.
 */
-(id)initWithDocument: (FSPDFDoc*)document;
/**
 * @brief Get the full page label title for a page specified by page index.
 *
 * @details This function can help to get the full page label title of a specified page index directly, and
 *          user does not need to take care about which page labeling range this page belongs to.
 *
 * @param[in] page_index  A page index. Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return The page label full title string, in UTF-8 encoding.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(NSString*)getPageLabelTitle: (int)page_index;

/**
 * @brief Check if there is a page labeling range starting from the specified page index.
 *
 * @details Each page labeling range has its own numbering format.
 *          The numbering format is defined with the start page of the page labeling range.
 *
 * @param[in] page_index  A page index. Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return <b>true</b> means there exists format information of a page labeling range with input page index,
 *         while <b>false</b> means there is no such format information with input page index.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(BOOL)hasPageLabel: (int)page_index;

/**
 * @brief Get the numbering style to be used for the numeric portion in a page labeling range
 *        starting from the specified page index.
 *
 * @details This function is only useful when input page index is the start page of a page labeling range.
 *          Function {@link FSPDFPageLabels::HasPageLabel}(with same page index) can be used to check this.
 *          If input page index is not the start page of any page labeling range, this function will return -1.
 *
 * @param[in] page_index  The page index which specifies the start page of a page labeling range.
 *                        Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return The the numbering style. Please refer to
 *         {@link FSPageLabelStyle::e_pageLabelStyleNone FSPageLabelStyle::e_pageLabelStyleXXX}
 *         and it would be one of these values.<br>
 *         -1 means input page index is not the start page of any page labeling range.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(FSPageLabelStyle)getPageLabelStyle: (int)page_index;
/**
 * @brief Get the label prefix string for page labels in a page labeling range
 *        starting from the specified page index.
 *
 * @details This function is only useful when input page index is the start page of a page labeling range.
 *          Function {@link FSPDFPageLabels::HasPageLabel}(with same page index) can be used to check this.
 *          If input page index is not the start page of any page labeling range, this function will
 *          return empty string.
 *
 * @param[in] page_index  The page index which specifies the start page of a page labeling range.
 *                        Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return The label prefix string, in UTF-8 encoding.
 *         Empty string means no prefix string is used or input page index is not the start page of
 *         any page labeling range.<br>
 *         Function {@link FSPDFPageLabels::HasPageLabel} can be used to check if there is a page labeling range
 *         starting from the specified page index.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(NSString*)getPageLabelPrefix: (int)page_index;
/**
 * @brief Get the value of the numeric portion for the first page label in a page labeling range
 *        starting from the specified page index.
 *
 * @details Subsequent pages are numbered sequentially from this value, which must be greater than or equal to 1.
 *
 * @param[in] page_index  The page index which specifies the start page of a page labeling range.
 *                        Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return The value of the numeric portion for the first page label in specific labeling range,
 *         which would be greater than or equal to 1.
 *         -1 means no first label number is defined or no format information of page labeling range is
 *         associated with input page index. Function {@link FSPDFPageLabels::HasFormatInfo} can be used to check
 *         if there exists such format information with input page index.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(int)getFirstLabelNumber: (int)page_index;

/**
 * @brief Set a page label (as numbering format) with a page index which is used to be the start page
 *        in the range.
 *
 * @details <ul>
 *          <li>If no page labeling range starts from input page index, this function will set input page index as
 *              the start page of a new page labeling range and use input values as the numbering format of
 *              this new range. Pages following the specified page will be in the same labeling range,
 *              until the next page labeling range appears.</li>
 *          <li>If there exists a page labeling range starting from input page index,
 *              this function will replace the old numbering format with input values.</li>
 *          </ul>
 *
 * @param[in] page_index          A page index as the start page of the page labeling range.
 *                                Valid range: from 0 to (<i>count</i>-1).
 *                                <i>count</i> is the page count of related PDF document,
 *                                which is returned by function {@link FSPDFDoc::getPageCount}.
 * @param[in] label_style         The the numbering style to be used for the numeric portion
 *                                in the page labeling range. Please refer to
 *                                {@link FSPageLabelStyle::e_pageLabelStyleNone FSPageLabelStyle::e_pageLabelStyleXXX}
 *                                and it should be one of these values.
 * @param[in] prefix_string       The label prefix string for page labels in the labeling range,
 *                                in UTF-8 encoding. This can be NULL or empty, which means not use prefix string.
 * @param[in] first_label_number  The value of the numeric portion for the first page label
 *                                in the page labeling range. It should be greater than or equal to 1.
 *                                If the input value is invalid, Foxit PDF SDK will use 1 by default.
 *
 * @return None.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(void)setPageLabel: (int)page_index label_style: (FSPageLabelStyle)label_style prefix_string: (NSString *)prefix_string first_label_number: (int)first_label_number;

/**
 * @brief Remove a page label associated with a specified page index.
 *
 * @details After the specified page label is removed, the specified labeling range will be merged with
 *          the previous page label sequence.
 *
 * @param[in] page_index  The page index which specifies the start page of a page labeling range.
 *                        Valid range: from 0 to (<i>count</i>-1).
 *                        <i>count</i> is the page count of related PDF document,
 *                        which is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return None.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(void)removePageLabel: (int)page_index;

/**
 * @brief Remove all page labeling ranges.
 *
 * @return None.
 *
 * @exception For more information about exception values,
 *                     please refer to {@link FSErrorCode::e_errFile FSErrorCode::e_errXXX}.
 */
-(void)removeAll;

-(void)dealloc;

@end

/**
 * @brief Enumeration for metadata key type.
 *
 * @details Values of this enumeration should be used alone.
 */
typedef NS_ENUM(NSUInteger, FSMetadataKeyType) {
    /**
     * @brief Standard metadata keys, including traditional standard keys ("Info" dictionary and XML) and
     *        Foxit standard keys.
     */
    e_metadataKeyTypeStandard = 0x01,
    /** @brief Custom metadata keys. */
    e_metadataKeyTypeCustom = 0x02
};

/**
 * In PDF document, metadata information is stored in document's Info dictionary or in metadata stream (represented
 * in Extensible Markup Language, known as XML). When a key exists in both Info dictionary and metadata stream,
 * the latest modified one will be used.<br>
 * This class is constructed from PDF document object and is used to get or set metadata information
 * from both document's Info dictionary and metadata stream.
 */
@interface FSPDFMetadata : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief Construct from a PDF document object.
 *
 * @details If there exists metadata information information in the specified PDF document,
 *          this function is just to construct a FSPDFMetadata object to be associated with these information.
 *          If there is no such information in the specified PDF document, the constructed FSPDFMetadata object
 *          can be used to set metadata information to PDF document.
 *
 * @param[in] document  A PDF document object. It should be valid and should not be <b>NULL</b>.
 */
-(id)initWithDocument: (FSPDFDoc*)document;
/**
 * @brief Check whether current document has a specified metadata key or not.
 *
 * @param[in] key  The metadata key to be confirmed. It should be in UTF-8 encoding.
 *
 * @return <b>true</b> means current document has the specified metadata key,
 *         while <b>false</b> means current document does not have the specified metadata key.
 */
-(BOOL)hasKey: (NSString *)key;
/**
 * @brief Get creation date time.
 *
 * @return The creation date time.
 *         Return nil if not found.
 */
-(FSDateTime * _Nullable)getCreationDateTime;
/**
 * @brief Get modified date time.
 *
 * @return The modified date time.
 *         Return nil if not found.
 */
-(FSDateTime * _Nullable)getModifiedDateTime;
/**
 * @brief Set creation date time.
 *
 * @param[in] date_time  New creation date time. Please refer to comment of class FSDateTime to check
 *                       the valid range for each member.
 *
 * @return None.
 */
-(void)setCreationDateTime: (FSDateTime*)date_time;
/**
 * @brief Set modified date time.
 *
 * @param[in] date_time  New modified date time. Please refer to comment of class FSDateTime to check
 *                       the valid range for each member.
 *
 * @return None.
 */
-(void)setModifiedDateTime: (FSDateTime*)date_time;
/**
 * @brief Get metadata value.
 *
 * @details For a metadata key, it can contain single or multiple values.
 *          This function is used to get the whole values for a metadata key.<br>
 *          For some metadata keys such as "Author" and "Keywords", they can contain single or multiple values.
 *          If user wants to get the values one by one, please use function
 *          {@link FSPDFMetadata::GetValueCount} and {@link FSPDFMetadata::GetValueByIndex}.
 *
 * @param[in] key  Metadata key string, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *                 Currently it can be one of the following keys:<br>
 *                 "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "Trapped",
 *                 "CreationDate", "ModDate", "pdfaid".<br>
 *                 Some other custom information keys, if they're supported by the PDF file.<br>
 *                 For "CreationDate" and "ModDate", user is recommended to use functions
 *                 {@link FSPDFMetadata::GetCreationDateTime} and {@link FSPDFMetadata::GetModifiedDateTime} to
 *                 get the date information.
 *
 * @return Metadata value string, in UTF-8 string.
 */
-(NSString * _Nullable)getValue: (NSString *)key;
/**
 * @brief Get the count of metadata value.
 *
 * @details For some metadata keys, such as "Author" and "Keywords", they can contain single or multiple values.
 *          This function is used to get the count of values,
 *          and then function {@link FSPDFMetadata::GetValueByIndex} can be used to get one of these values.<br>
 *          If user just wants to get the whole values, please use function {@link FSPDFMetadata::GetValue}.
 *
 * @param[in] key  Metadata key string, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *                 Currently it can be one of the following keys:<br>
 *                 "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "Trapped",
 *                 "CreationDate", "ModDate", "pdfaid".<br>
 *                 Some other custom information keys, if they're supported by the PDF file.<br>
 *                 For "CreationDate" and "ModDate", user is recommended to use functions
 *                 {@link FSPDFMetadata::GetCreationDateTime} and {@link FSPDFMetadata::GetModifiedDateTime} to
 *                 get the date information.
 *
 * @return The count of metadata value.
 */
-(int)getValueCount: (NSString *)key;
/**
 * @brief Get metadata value by index.
 *
 * @details For some metadata keys, such as "Author" and "Keywords", they can contain single or multiple values.
 *          This function is used to get one of these values.<br>
 *          If user just wants to get the whole values, please use function {@link FSPDFMetadata::GetValue}.
 *
 * @param[in] key    Metadata key string, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *                   Currently it can be one of the following keys:<br>
 *                   "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "Trapped",
 *                   "CreationDate", "ModDate", "pdfaid".<br>
 *                   Some other custom information keys, if they're supported by the PDF file.<br>
 *                   For "CreationDate" and "ModDate", user is recommended to use functions
 *                   {@link FSPDFMetadata::GetCreationDateTime} and {@link FSPDFMetadata::GetModifiedDateTime} to
 *                   get the date information.
 * @param[in] index  The index of metadata value.Valid range: from 0 to (<i>count</i>-1).
 *                   <i>count</i> is returned by function {@link FSPDFMetadata::GetValueCount}.
 *
 * @return Metadata value string, in UTF-8 string.
 */
-(NSString*)getValueByIndex: (NSString *)key index: (int)index;
/**
 * @brief Set the array of metadata values.
 *
 * @details This function is used to set single or multiple values to a specified metadata key:
 *          <ul>
 *          <li>For metadata keys "Author" and "Keywords", they can contain single or multiple values.</li>
 *          <li>For metadata key "pdfaid" which means the PDFA file version, the length of its value string is
 *              always 2, such as "2a", "1a" and so on. So, only the first two characters of the first element
 *              in parameter <i>valueArray</i> will be used.</li>
 *          <li>For rest pre-defined keys, they do not support multiple values. So all the elements in
 *              parameter <i>valueArray</i> will be put into one string and connected by ";".
 *              Then this string will be treated as one value.</li>
 *          </ul>
 *
 * @param[in] key          Metadata key string, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *                         Currently it can be one of the following keys:<br>
 *                         "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "Trapped",
 *                         "CreationDate", "ModDate", "pdfaid".<br>
 *                         Some other custom information keys, if they're supported by the PDF file.<br>
 *                         For "CreationDate" and "ModDate", user is recommended to use functions
 *                         {@link FSPDFMetadata::SetCreationDateTime} and {@link FSPDFMetadata::SetModifiedDateTime}
 *                         to set the date information.
 * @param[in] value_array  The array of metadata value string, in UTF-8 string. It should not be <b>NULL</b>.
 * @param[in] count        The count of elements in parameter <i>value_array</i>.
 *
 * @return None.
 */
-(void)setValues: (NSString *)key value_array:(NSArray<NSString*>*)value_array;
/**
 * @brief Get keys from metadata (both Info dictionary and metadata stream) according to specified type.
 *
 * @details In Info dictionary and metadata stream, they have some standard keys which have same feature
 *          but different name. For this case, Foxit PDF SDK will use the standard key names in Info dictionary.
 *
 * @param[in] key_type  Key type to specify which kind of keys will be retrieved. Please refer to
 *                      {@link FSMetadataKeyType::e_metadataKeyTypeStandard FSMetadataKeyType::e_metadataKeyTypeXXX}
 *                      values and this should be one or a combination of these values.
 *
 * @return An array of key strings. Each string in this list would be in UTF-8 encoding.
 */
-(NSArray<NSString *> * _Nullable)getKeys: (FSMetadataKeyType)key_type;
/**
 * @brief Remove a specified key (with related value).
 *
 * @param[in] key  Metadata key string, in UTF-8 encoding. It should not be <b>NULL</b> or empty.
 *                 Currently it can be one of the following keys:<br>
 *                 "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "Trapped",
 *                 "CreationDate", "ModDate", "pdfaid".<br>
 *                 Some other custom information keys, if they're supported by the PDF file.<br>
 *
 * @return None.
 */
-(void)removeKey: (NSString *)key;

-(void)dealloc;

@end

NS_ASSUME_NONNULL_END
